//// Function declarations//vec4 randomizer4( const vec4 x );float cnoise4( const vec3 xx );float getDistanceForPoint( in vec3 point );vec4 pixelMain( in vec2 TexCoords, in vec3 LStart, in vec3 LEnd );float planeNoise( in vec3 point );float getDistanceForPlaneY( in vec3 point, in float offset );//// Function definitions//vec4 randomizer4( const vec4 x ) {    vec4 z;    float tVal = 6.28319;    z = mod( x, vec4( 5612.00, 5612.00, 5612.00, 5612.00));    z = mod( z, vec4( tVal, tVal, tVal, tVal));    return fract( (cos( z ) * vec4( 56812.5, 56812.5, 56812.5, 56812.5)) );}float cnoise4( const vec3 xx ) {    vec3 x;    vec3 ix;    vec3 fx;    vec3 wx;    float nn;    vec4 N1;    vec4 N2;    vec4 R1;    vec4 R2;    vec4 R;    float re;    x = mod( (xx + vec3( 32768.0, 32768.0, 32768.0)), vec3( 65536.0, 65536.0, 65536.0));    ix = floor( x );    fx = fract( x );    wx = ((fx * fx) * (vec3( 3.00000, 3.00000, 3.00000) - (2.00000 * fx)));    nn = dot( ix, vec3( 1.00000, 57.0000, 113.000));    N1 = (nn + vec4( 0.000000, 57.0000, 113.000, 170.000));    N2 = (nn + vec4( 1.00000, 58.0000, 114.000, 171.000));    R1 = randomizer4( N1);    R2 = randomizer4( N2);    R = mix( R1, R2, vec4( wx.x ));    re = mix( mix( R.x , R.y , wx.y ), mix( R.z , R.w , wx.y ), wx.z );    return (1.00000 - (2.00000 * re));}float getDistanceForPoint( in vec3 point ) {    return getDistanceForPlaneY( point, -40.0000);}vec4 pixelMain( in vec2 TexCoords, in vec3 LStart, in vec3 LEnd ) {    vec3 lVec;    vec3 lDir;    float lLength;    vec4 finalColour = vec4( 0.000000, 0.000000, 0.000000, 1.00000);    float distTravelled = 0.000000;    bool distHit = false;    float cFac = 0.000000;    float farValue = 500.000;    vec3 currentWPos;    float currentDist;    lVec = (LEnd - LStart);    lDir = normalize( lVec );    lLength = length( lVec );    while ( ((distTravelled < farValue) && ( !distHit )) ) {        currentWPos = (LStart + (lDir * distTravelled));        currentDist = getDistanceForPoint( currentWPos);        cFac += 0.0200000;        if ( (currentDist < 0.0100000) ){            finalColour = vec4( 1.00000, 1.00000, 1.00000, 1.00000);            distHit = true;        }        else{            distTravelled += currentDist;        }    }    finalColour = vec4( cFac, 0.000000, 0.000000, 1.00000);    return finalColour;}float planeNoise( in vec3 point ) {    return (((cnoise4( (point / 5.00000)) * 20.0000) + (cnoise4( point) * 5.00000)) + cnoise4( (point * 5.00000)));}float getDistanceForPlaneY( in vec3 point, in float offset ) {    vec3 tempPoint;    tempPoint = vec3( point.x , (point.y  + planeNoise( vec3( (point.x  / 25.0000), 10.0000, (point.z  / 25.0000)))), point.z );    return max( abs( (tempPoint.y  - offset) ), 0.000000);}//// Translator's entry point//void main() {    vec4 xlat_retVal;    xlat_retVal = pixelMain( vec2(gl_TexCoord[0]), vec3(gl_TexCoord[1]), vec3(gl_TexCoord[2]));    gl_FragData[0] = vec4( xlat_retVal);}