#ifndef __COLLISION_SHAPE_H_INCLUDED__
#define __COLLISION_SHAPE_H_INCLUDED__

#define SPHERE_MULTIPLIER = 5.0
#define BOX_MULTIPLIER


#include "common.h"
#include "Bullet/BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h"


enum ECollisionShapeType
{
    ECST_BOX,
    ECST_CONE,
    ECST_SPHERE,
    ECST_BVHTRIMESH,
    ECST_CONVEXHULL,
    ECST_GIMPACT
};

enum EScalingPair
{
    ESP_BOTH,
    ESP_COLLISIONSHAPE,
    ESP_VISUAL
};

class ICollisionShape
{
public:
    ICollisionShape();

    virtual ~ICollisionShape();

    //////////////////////////
    // The 'dos' and 'sets' //
    //////////////////////////
    void setLocalScaling(const irr::core::vector3df &scaling, const EScalingPair esp);

    void setMargin(const irr::f32 margin) { shape->setMargin(margin); };

    void calculateLocalInertia(const irr::core::vector3df &in);


    ///////////////////
    // The 'getters' //
    ///////////////////
    irr::core::vector3df getLocalScaling() const;

    irr::core::stringc getName() const { return (irr::core::stringc)shape->getName(); };

    ECollisionShapeType getShapeType() const { return type; };

    irr::f32 ICollisionShape::getMargin() const { return shape->getMargin(); };

    irr::core::vector3df getLocalInertia() const { return localInertia; };

    irr::f32 getMass() const {return mass;};

    btCollisionShape *getPointer() {return shape;};

    irr::scene::ISceneNode *getNode() const {return node;};

    bool isPolyhedral() const { return shape->isPolyhedral(); };
    bool isConvex() const { return shape->isConvex(); };
    bool isConcave() const { return shape->isConcave(); };
    bool isCompound() const { return shape->isCompound(); };
    bool isInfinite() const { return shape->isInfinite(); };

protected:
    ECollisionShapeType type;
    irr::scene::ISceneNode *node;
    btCollisionShape *shape;

    irr::f32 mass;
    irr::core::vector3df localInertia;

    // Functions
    virtual void createShape();
};


#endif // __COLLISION_SHAPE_H_INCLUDED__
