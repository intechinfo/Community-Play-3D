<?xml version="1.0"?>

<rootScene>

	<config>

		 <numberOfObjects value="2" />

		 <grid>

			 <accentLineOffset ALO="8" />
			 <size S="1024" />
			 <spacing SP="8" />

		 </grid>

		 <camera>

			 <position X="-82.648636" Y="44.626427" Z="-17.700905" />
			 <rotation X="36.474342" Y="185.178497" Z="0.000000" />

		 </camera>

		 <fpsCameraSettings>

			 <ellipsoidRadius X="5.000000" Y="2.000000" Z="5.000000" />
			 <gravityPerSecond X="0.000000" Y="-0.100000" Z="0.000000" />
			 <ellipsoidTranslation X="0.000000" Y="2.000000" Z="0.000000" />
			 <slidingValue value="0.000500" />

		 </fpsCameraSettings>

		 <effect>

			 <postProcessingEffect>
				 <file_path path="shaders/hlsl/bloomp.hlsl" />
				 <values>
				 </values>
			 </postProcessingEffect>

			 <postProcessingEffect>
				 <file_path path="shaders/hlsl/hdr.hlsl" />
				 <values>
				 </values>
			 </postProcessingEffect>


		 </effect>

		 <materialTypes>

			 <materialType>
				 <pixelShaderType type="7" /> 
				 <vertexShaderType type="3" /> 
				 <baseMaterial type="0" /> 
				 <name cname="normal_mapping_package.spkg" />
				 <vertex shader=
"float4x4 matWorldInverse; 
float4x4 ModelViewMatrix;
float4x4 ModelViewProjectionMatrix;
float3 fvLightPosition1; 
float3 fvLightPosition2; 
float3 fvLightPosition3; 
float3 fvLightPosition4; 
float fLightStrength1; 
float fLightStrength2; 
float fLightStrength3; 
float fLightStrength4; 
struct VS_OUTPUT
{
   float4 Position            : POSITION0;
   float2 Texcoord            : TEXCOORD0;
   float3 ViewDirection      : TEXCOORD1; 
   float3 LightDirection1      : TEXCOORD2; 
   float3 LightDirection2      : TEXCOORD3; 
   float3 LightDirection3      : TEXCOORD4; 
   float3 LightDirection4      : TEXCOORD5; 
   float4 LightDistMultiplier  : TEXCOORD6;
};
float getLengthSQR (float3 vec) 
{ 
   return(vec.x*vec.x+vec.y*vec.y+vec.z*vec.z); 
}  
struct VS_INPUT
{
   float3 Position         : POSITION0;
   float3 Normal           : NORMAL;
   float2 Texcoord         : TEXCOORD0;
};
VS_OUTPUT vertexMain( in VS_INPUT IN ) 
{    
   VS_OUTPUT OUT = (VS_OUTPUT)0;
   OUT.Position = mul(float4(IN.Position,1.0), ModelViewProjectionMatrix);
   OUT.Texcoord = IN.Texcoord;
   
   float4x4 LightTransform= ModelViewMatrix; 
   LightTransform= mul(matWorldInverse, LightTransform);
   float4 fvObjectPosition = mul(float4(IN.Position,1.0), ModelViewProjectionMatrix);
   float4 fvLightPos1 = mul(float4(fvLightPosition1,1.0), LightTransform); 
   float4 fvLightPos2 = mul(float4(fvLightPosition2,1.0), LightTransform); 
   float4 fvLightPos3 = mul(float4(fvLightPosition3,1.0), LightTransform); 
   float4 fvLightPos4 = mul(float4(fvLightPosition4,1.0), LightTransform); 
   float3 fvViewDirection  =  - fvObjectPosition.xyz; 
   float3 fvLightDirection1 = (fvLightPos1.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection2 = (fvLightPos2.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection3 = (fvLightPos3.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection4 = (fvLightPos4.xyz - fvObjectPosition.xyz); 
   
   OUT.LightDistMultiplier[0]=1.0/(getLengthSQR (fvLightDirection1)/(fLightStrength1*10000.0)); 
   OUT.LightDistMultiplier[1]=1.0/(getLengthSQR (fvLightDirection2)/(fLightStrength2*10000.0)); 
   OUT.LightDistMultiplier[2]=1.0/(getLengthSQR (fvLightDirection3)/(fLightStrength3*10000.0)); 
   OUT.LightDistMultiplier[3]=1.0/(getLengthSQR (fvLightDirection4)/(fLightStrength4*10000.0)); 
   
   float3 fvTangent   = -float3(abs(IN.Normal.y) + abs(IN.Normal.z), abs(IN.Normal.x), 0); 
   float3 fvBinormal   = cross(fvTangent,IN.Normal);
   float3 fvNormal     = mul(IN.Normal, ModelViewMatrix); 
   fvTangent         = mul( cross(fvBinormal, IN.Normal), ModelViewMatrix ); 
   fvBinormal         = mul( fvBinormal, ModelViewMatrix ); 
   
   OUT.ViewDirection.x  = dot( fvTangent, fvViewDirection ); 
   OUT.ViewDirection.y  = dot( fvBinormal, fvViewDirection ); 
   OUT.ViewDirection.z  = dot( fvNormal, fvViewDirection ); 
   OUT.LightDirection1.x  = dot( fvTangent, fvLightDirection1.xyz ); 
   OUT.LightDirection1.y  = dot( fvBinormal, fvLightDirection1.xyz ); 
   OUT.LightDirection1.z  = dot( fvNormal, fvLightDirection1.xyz ); 
   OUT.LightDirection2.x  = dot( fvTangent, fvLightDirection2.xyz ); 
   OUT.LightDirection2.y  = dot( fvBinormal, fvLightDirection2.xyz ); 
   OUT.LightDirection2.z  = dot( fvNormal, fvLightDirection2.xyz ); 
   OUT.LightDirection3.x  = dot( fvTangent, fvLightDirection3.xyz ); 
   OUT.LightDirection3.y  = dot( fvBinormal, fvLightDirection3.xyz ); 
   OUT.LightDirection3.z  = dot( fvNormal, fvLightDirection3.xyz ); 
   OUT.LightDirection4.x  = dot( fvTangent, fvLightDirection4.xyz ); 
   OUT.LightDirection4.y  = dot( fvBinormal, fvLightDirection4.xyz ); 
   OUT.LightDirection4.z  = dot( fvNormal, fvLightDirection4.xyz ); 
   
   return OUT;
}
" />
				 <pixel shader=
"float4 fvAmbient;
float4 fvLight1Color; 
float4 fvLight2Color; 
float4 fvLight3Color; 
float4 fvLight4Color; 
float fSpecularPower; 
float fSpecularStrength; 
float fBumpStrength; 
sampler2D baseMap      : register(s0); 
sampler2D bumpMap      : register(s1); 
struct PS_INPUT
{   
   float2 Texcoord            : TEXCOORD0;
   float3 ViewDirection      : TEXCOORD1; 
   float3 LightDirection1      : TEXCOORD2; 
   float3 LightDirection2      : TEXCOORD3;
   float3 LightDirection3      : TEXCOORD4; 
   float3 LightDirection4      : TEXCOORD5; 
   float4 LightDistMultiplier  : TEXCOORD6;
};
float4 pixelMain( in PS_INPUT IN ) : COLOR
{
   float4 color = float4(0,0,0,0);
   float3  fvLightDirection1 = normalize( IN.LightDirection1 ); 
   float3  fvLightDirection2 = normalize( IN.LightDirection2 ); 
   float3  fvLightDirection3 = normalize( IN.LightDirection3 ); 
   float3  fvLightDirection4 = normalize( IN.LightDirection4 ); 
   float3  fvNormal          = tex2D( bumpMap, IN.Texcoord ).yxz; 
   
   fvNormal.xy*=2.0; 
   fvNormal.xy-=1.0;
   fvNormal=(float3(0.0,0.0,1.0)-fvNormal)*fBumpStrength+fvNormal; 
   fvNormal=normalize(fvNormal);
   
   float fNDotL1           = max(dot(fvNormal, fvLightDirection1),0.0)-0.1;  
   float fNDotL2           = max(dot(fvNormal, fvLightDirection2),0.0)-0.1;  
   float fNDotL3           = max(dot(fvNormal, fvLightDirection3),0.0)-0.1;  
   float fNDotL4           = max(dot(fvNormal, fvLightDirection4),0.0)-0.1;  
   float3  fvReflection1     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection1 );  
   float3  fvReflection2     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection2 );  
   float3  fvReflection3     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection3 );  
   float3  fvReflection4     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection4 );  
   float3  fvViewDirection  = normalize( IN.ViewDirection ); 
   float fRDotV1          = max( 0.0, dot( fvReflection1, fvViewDirection ) ); 
   float fRDotV2          = max( 0.0, dot( fvReflection2, fvViewDirection ) ); 
   float fRDotV3          = max( 0.0, dot( fvReflection3, fvViewDirection ) ); 
   float fRDotV4          = max( 0.0, dot( fvReflection4, fvViewDirection ) ); 
   float4  fvBaseColor      = tex2D( baseMap, IN.Texcoord ); 
   float4  fvTotalAmbient   = fvAmbient * fvBaseColor;  
   float4  fvTotalDiffuse   = fvLight1Color * fNDotL1* fvBaseColor*IN.LightDistMultiplier[0];  
   float4  fvTotalSpecular  = fNDotL1*fvLight1Color * ( pow( fRDotV1, fSpecularPower ) )*IN.LightDistMultiplier[0]; 
   fvTotalDiffuse   += fvLight2Color * fNDotL2* fvBaseColor*IN.LightDistMultiplier[1];  
   fvTotalSpecular  += fNDotL2*fvLight2Color * ( pow( fRDotV2, fSpecularPower ) )*IN.LightDistMultiplier[1];   
   fvTotalDiffuse   += fvLight3Color * fNDotL3* fvBaseColor*IN.LightDistMultiplier[2];  
   fvTotalSpecular  += fNDotL3*fvLight3Color * ( pow( fRDotV3, fSpecularPower ) )*IN.LightDistMultiplier[2];   
   fvTotalDiffuse   += fvLight4Color * fNDotL4* fvBaseColor*IN.LightDistMultiplier[3];  
   fvTotalSpecular  += fNDotL4*fvLight4Color * ( pow( fRDotV4, fSpecularPower ) )*IN.LightDistMultiplier[3];   
   color=( fvTotalAmbient + fvTotalDiffuse+ (fvTotalSpecular*fSpecularStrength)); 
   if(color.r>1.0){color.gb+=color.r-1.0;} 
   if(color.g>1.0){color.rb+=color.g-1.0;} 
   if(color.b>1.0){color.rg+=color.b-1.0;} 
   
   return color;
}
" />
				 <constants value="vmatrix4 ModelViewProjectionMatrix proj[0] view[0] world[0] dontMakeInverse
vmatrix4 ModelViewMatrix view[0] world[0] 0 dontMakeInverse
vmatrix4 matWorldInverse world[0] 0 0 makeInverse

vfloat fLightStrength1 80
vfloat fLightStrength2 80
vfloat fLightStrength3 80
vfloat fLightStrength4 80

vvector3df fvLightPosition1 150 240 -34
vvector3df fvLightPosition2 150 240 -34
vvector3df fvLightPosition3 150 240 -34
vvector3df fvLightPosition4 150 240 -34

pSColor fvAmbient 1 0.7 0.7 0.7
pSColor fvLight1Color 1 0.02 0.02 0.02
pSColor fvLight2Color 1 0.02 0.02 0.02
pSColor fvLight3Color 1 0.02 0.02 0.02
pSColor fvLight4Color 1 0.02 0.02 0.02

pfloat fSpecularPower 20
pfloat fSpecularStrength 0.9
pfloat fBumpStrength 5
" />
			 </materialType>

			 <materialType>
				 <pixelShaderType type="0" /> 
				 <vertexShaderType type="0" /> 
				 <baseMaterial type="0" /> 
				 <name cname="triplanar_nm_package.spkg" />
				 <vertex shader=
"float4x4 matWorldViewProjection;float4x4 matWorld;float tileSize;float3 viewPos;struct VS_INPUT {   float4 Position : POSITION0;   float2 Texcoord : TEXCOORD0;   float3 Normal :   NORMAL0; };struct VS_OUTPUT {   float4 Position :        POSITION0;   float  Fog		:       FOG0;   float2 TexcoordX :       TEXCOORD0;   float2 TexcoordY :       TEXCOORD1;   float2 TexcoordZ :       TEXCOORD2;   float3 viewDirection   : TEXCOORD3;      float3x3 tangentSpace :  TEXCOORD4;};VS_OUTPUT vertexMain( VS_INPUT Input ){   VS_OUTPUT Output;   Output.Position         = mul( Input.Position, matWorldViewProjection );   float3 realPos          = mul( Input.Position,matWorld).xyz;      Output.viewDirection = realPos-viewPos;      Output.TexcoordX         = realPos.zy/tileSize;   Output.TexcoordY         = realPos.xz/tileSize;   Output.TexcoordZ         = realPos.xy/tileSize;      float3 worldNormal = normalize(Input.Normal);   float3 n = worldNormal;   n*=n;      float3 xtan,ytan,ztan;   float3 xbin,ybin,zbin;      xtan = float3(0,0,1);   xbin = float3(0,1,0);      ytan = float3(1,0,0);   ybin = float3(0,0,1);      ztan = float3(1,0,0);   zbin = float3(0,1,0);      float3 worldBinormal = normalize(xbin*n.x+ybin*n.y+zbin*n.z);   float3 worldTangent = normalize(xtan*n.x+ytan*n.y+ztan*n.z);      worldNormal = mul(matWorld,worldNormal);   worldBinormal = mul(matWorld,worldBinormal);   worldTangent = mul(matWorld,worldTangent);      Output.tangentSpace[0]   = worldTangent;   Output.tangentSpace[1]   = worldBinormal;    Output.tangentSpace[2]   = worldNormal;   Output.Fog = Output.Position.z/Output.Position.w;         return( Output );   }" />
				 <pixel shader=
"float4 ambient;float4 specular;float4 diffuse;float specularPower;float3 lightDirection;sampler2D baseX : register(s0);sampler2D baseY : register(s1);sampler2D normalX : register(s2);sampler2D normalY : register(s3);struct PS_INPUT {   float4 Position :        POSITION0;   float2 TexcoordX :       TEXCOORD0;   float2 TexcoordY :       TEXCOORD1;   float2 TexcoordZ :       TEXCOORD2;   float3 viewDirection   : TEXCOORD3;      float3x3 tangentSpace :  TEXCOORD4;};float4 pixelMain( PS_INPUT Input ) : COLOR0{         float3 fvLightDirection = normalize( lightDirection );   float3 fvNormal         = normalize( Input.tangentSpace[2]);   float3 fvViewDirection  = normalize( Input.viewDirection );       float3 n                = fvNormal;   n*=n;      float4 fvBaseColor      = tex2D( baseX, Input.TexcoordX )*n.x+                             tex2D( baseY, Input.TexcoordY )*n.y+                             tex2D( baseX, Input.TexcoordZ )*n.z;   float4 fvBaseNormal     = tex2D( normalX, Input.TexcoordX )*n.x+                             tex2D( normalY, Input.TexcoordY )*n.y+                             tex2D( normalX, Input.TexcoordZ )*n.z;                                float3 normal           = normalize(mul(2.0*fvBaseNormal.xyz-1.0,Input.tangentSpace));           float  fNDotL           = max(0.0,dot( normal, fvLightDirection ));    float3 fvReflection     = reflect(fvLightDirection,normal);   float  fRDotV           = max(0.0, dot( fvReflection, fvViewDirection ) );                                float4 fvTotalAmbient   = ambient * fvBaseColor;    float4 fvTotalDiffuse   = diffuse * fNDotL * fvBaseColor;    float4 fvTotalSpecular  = specular * pow( fRDotV, specularPower )*fvBaseColor;      return( fvTotalAmbient + fvTotalDiffuse + fvTotalSpecular );      }" />
				 <constants value="vmatrix4 matWorldViewProjection proj[0] view[0] world[0] 0vmatrix4 matWorld world[0] 0 0 0vvector3df viewPos camPos4pvector3df lightDirection -10.1 10.0 10.1pSColori ambiant 255 118 86 86pSColori specular 255 205 209 86pSColori diffuse 255 118 132 204vfloat tileSize 10pfloat specularPower 1" />
			 </materialType>


		 </materialTypes>

		 <scripts>


		 </scripts>

	</config>



	<scene>

		 <terrain>

			 <path file="C:/Users/julienmoreau-mathis/Desktop/Soganatsu/SSWE/height_maps/julie_is_gay_1.png" />

			 <type esnt="heightMap" />

			 <factory> 


			 </factory> 

			 <name c8name="#map:terrain" />

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="height_maps/rock.png" />
						 <texture id="1" path="height_maps/grass.png" />
						 <texture id="2" path="height_maps/rockn.png" />
						 <texture id="3" path="height_maps/grassn.png" />
					 <textures>

					 <diffuseColor r="118" g="132" b="204" a="255" />
					 <ambiantColor r="118" g="86" b="86" a="255" />
					 <specularColor r="205" g="209" b="96" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="100.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="4.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-2" />

			 	 </material>
			 </materials>
			 <position X="-319.360687" Y="0.500000" Z="-327.284302" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="1.000000" Y="0.200000" Z="1.000000" />

			 <visible bool="1" />
			 <shadowMode mode="2" />

		 </terrain>

		 <light>

			 <name c8name="#light:1" />

			 <position X="-473.318756" Y="280.000000" Z="-416.091125" />
			 <target X="0.000000" Y="0.000000" Z="0.000000" />

			 <diffuseColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />
			 <ambiantColor r="0.000000" g="0.000000" b="0.000000" a="1.000000" />
			 <specularColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />

			 <radius value="100.000000" />
			 <farValue value="1400.000000" />
			 <autoRecalculate value="0" />

			 <shadows resol="4096" />

			 <lensFlare>
			 </lensFlare>

		 </light>


	</scene>

</rootScene>
