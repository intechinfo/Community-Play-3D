<?xml version="1.0"?>

<rootScene>

	<config>

		 <numberOfObjects value="7" />

		 <grid>

			 <accentLineOffset ALO="8" />
			 <size S="1024" />
			 <spacing SP="8" />

		 </grid>

		 <camera>

			 <position X="267.256805" Y="153.557480" Z="203.290710" />
			 <rotation X="13.677740" Y="179.821533" Z="0.000000" />

		 </camera>

		 <fpsCameraSettings>

			 <ellipsoidRadius X="30.000000" Y="60.000000" Z="30.000000" />
			 <gravityPerSecond X="0.000000" Y="-10.000000" Z="0.000000" />
			 <ellipsoidTranslation X="0.000000" Y="0.000000" Z="0.000000" />
			 <slidingValue value="0.000500" />

		 </fpsCameraSettings>

		 <depthPassEnabled enabled="1" />
		 <lightScaterringPassEnabled enabled="1" />
		 <reflectionPassEnabled enabled="1" />

		 <effect>

			 <postProcessingEffect>
				 <ppeName name="/bloomp.hlsl" />
				 <ppeShader shader="sampler2D ColorMapSampler : register(s0);
sampler2D ReflectionSampler : register(s1);
sampler2D NormalSampler : register(s2);
sampler2D ScreenMapSampler : register(s3);

float4 pixelMain(float2 TexCoords : TEXCOORD0) : COLOR0
{
    float4 nms = tex2D(NormalSampler, TexCoords);
    
    float4 cms = tex2D(ColorMapSampler, TexCoords)
    + tex2D(ReflectionSampler, float2(TexCoords.x, -TexCoords.y))
    * nms.g * 0.2
    + tex2D(ScreenMapSampler, TexCoords) * nms;
    
    return cms;
}
" />
				 <ppeCallback callback="filter:setRttTextureAtIndex(1, &quotReflectionPassRTT&quot)
filter:setRttTextureAtIndex(2, &quotNormalPassRTT&quot)
filter:setRttTextureAtIndex(3, &quotScreenMapSampler&quot)
" />
			 </postProcessingEffect>

			 <postProcessingEffect>
				 <ppeName name="/godrays.hlsl" />
				 <ppeShader shader="
sampler2D ColorMapSampler : register(s0);
sampler2D LuminanceSampler : register(s1);
sampler2D LensSampler : register(s2);
sampler2D UserMapSampler : register(s3);

float2 lightPositionOnScreen;
		
//float decay=0.96815;
//float exposure=0.2;
//float density=0.26;
//float weight=0.58767;

float4 pixelMain(float2 texCoord : TEXCOORD0) : COLOR0
{
	float decay=0.97815;
	float exposure=0.92;
	float density=0.966;
	float weight=0.58767;

	int NUM_SAMPLES = 50;
	
	float2 tc = texCoord;
 	float2 deltaTexCoord = (tc - lightPositionOnScreen.xy);  
 	deltaTexCoord *= 1.0f / NUM_SAMPLES * density;  
 	
 	float illuminationDecay = 1.0;

	float4 color =tex2D(UserMapSampler, tc)*0.4;
	
 	for(int i=0; i < NUM_SAMPLES ; i++)
  	{
		tc -= deltaTexCoord;
		float4 sample = tex2D(UserMapSampler, tc)*0.4;
		sample *= illuminationDecay * weight;  
		color += sample;
		illuminationDecay *= decay;  
 	}

 	float4 realColor = tex2D(ColorMapSampler, texCoord.xy);
 
  float4 lensColor = tex2D(LensSampler, texCoord.xy);
  lensColor.b = 0.0;
  lensColor.g = lensColor.r / 2.0;
  realColor += lensColor * color * 10.0;
  
  float4 lumColor = tex2D(LuminanceSampler, texCoord.xy);
  realColor += lumColor * lensColor;
  
  color *= 0.5;

	return ((float4((float3(color.r,color.g,color.b) * exposure),1))+(realColor*(1.5-0.4)));
}

" />
				 <ppeCallback callback="driver:setRttTexture(&quotLightScatteringRTT&quot)

position = utils:getScreenCoordinatesFrom3DPosition(driver:getLightPosition(0))
position.y = 1-position.y

filter:setRttTextureAtIndex(1, &quotLuminanceGeneratorStep0&quot)
filter:setTextureAtIndex(2, &quotshaders/Textures/LF/lensdirt.png&quot)
filter:setPixelShaderConstantVector2D(&quotlightPositionOnScreen&quot, position)

" />
			 </postProcessingEffect>


		 </effect>

		 <materialTypes>

			 <materialType>
				 <pixelShaderType type="7" /> 
				 <vertexShaderType type="3" /> 
				 <baseMaterial type="0" /> 
				 <name cname="normal_mapping_package.spkg" />
				 <vertex shader=
"float4x4 matWorldInverse; 
float4x4 ModelViewMatrix;
float4x4 ModelViewProjectionMatrix;
float3 fvLightPosition1; 
float3 fvLightPosition2; 
float3 fvLightPosition3; 
float3 fvLightPosition4; 
float fLightStrength1; 
float fLightStrength2; 
float fLightStrength3; 
float fLightStrength4; 
struct VS_OUTPUT
{
   float4 Position            : POSITION0;
   float2 Texcoord            : TEXCOORD0;
   float3 ViewDirection      : TEXCOORD1; 
   float3 LightDirection1      : TEXCOORD2; 
   float3 LightDirection2      : TEXCOORD3; 
   float3 LightDirection3      : TEXCOORD4; 
   float3 LightDirection4      : TEXCOORD5; 
   float4 LightDistMultiplier  : TEXCOORD6;
};
float getLengthSQR (float3 vec) 
{ 
   return(vec.x*vec.x+vec.y*vec.y+vec.z*vec.z); 
}  
struct VS_INPUT
{
   float3 Position         : POSITION0;
   float3 Normal           : NORMAL;
   float2 Texcoord         : TEXCOORD0;
};
VS_OUTPUT vertexMain( in VS_INPUT IN ) 
{    
   VS_OUTPUT OUT = (VS_OUTPUT)0;
   OUT.Position = mul(float4(IN.Position,1.0), ModelViewProjectionMatrix);
   OUT.Texcoord = IN.Texcoord;
   
   float4x4 LightTransform= ModelViewMatrix; 
   LightTransform= mul(matWorldInverse, LightTransform);
   float4 fvObjectPosition = mul(float4(IN.Position,1.0), ModelViewProjectionMatrix);
   float4 fvLightPos1 = mul(float4(fvLightPosition1,1.0), LightTransform); 
   float4 fvLightPos2 = mul(float4(fvLightPosition2,1.0), LightTransform); 
   float4 fvLightPos3 = mul(float4(fvLightPosition3,1.0), LightTransform); 
   float4 fvLightPos4 = mul(float4(fvLightPosition4,1.0), LightTransform); 
   float3 fvViewDirection  =  - fvObjectPosition.xyz; 
   float3 fvLightDirection1 = (fvLightPos1.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection2 = (fvLightPos2.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection3 = (fvLightPos3.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection4 = (fvLightPos4.xyz - fvObjectPosition.xyz); 
   
   OUT.LightDistMultiplier[0]=1.0/(getLengthSQR (fvLightDirection1)/(fLightStrength1*10000.0)); 
   OUT.LightDistMultiplier[1]=1.0/(getLengthSQR (fvLightDirection2)/(fLightStrength2*10000.0)); 
   OUT.LightDistMultiplier[2]=1.0/(getLengthSQR (fvLightDirection3)/(fLightStrength3*10000.0)); 
   OUT.LightDistMultiplier[3]=1.0/(getLengthSQR (fvLightDirection4)/(fLightStrength4*10000.0)); 
   
   float3 fvTangent   = -float3(abs(IN.Normal.y) + abs(IN.Normal.z), abs(IN.Normal.x), 0); 
   float3 fvBinormal   = cross(fvTangent,IN.Normal);
   float3 fvNormal     = mul(IN.Normal, ModelViewMatrix); 
   fvTangent         = mul( cross(fvBinormal, IN.Normal), ModelViewMatrix ); 
   fvBinormal         = mul( fvBinormal, ModelViewMatrix ); 
   
   OUT.ViewDirection.x  = dot( fvTangent, fvViewDirection ); 
   OUT.ViewDirection.y  = dot( fvBinormal, fvViewDirection ); 
   OUT.ViewDirection.z  = dot( fvNormal, fvViewDirection ); 
   OUT.LightDirection1.x  = dot( fvTangent, fvLightDirection1.xyz ); 
   OUT.LightDirection1.y  = dot( fvBinormal, fvLightDirection1.xyz ); 
   OUT.LightDirection1.z  = dot( fvNormal, fvLightDirection1.xyz ); 
   OUT.LightDirection2.x  = dot( fvTangent, fvLightDirection2.xyz ); 
   OUT.LightDirection2.y  = dot( fvBinormal, fvLightDirection2.xyz ); 
   OUT.LightDirection2.z  = dot( fvNormal, fvLightDirection2.xyz ); 
   OUT.LightDirection3.x  = dot( fvTangent, fvLightDirection3.xyz ); 
   OUT.LightDirection3.y  = dot( fvBinormal, fvLightDirection3.xyz ); 
   OUT.LightDirection3.z  = dot( fvNormal, fvLightDirection3.xyz ); 
   OUT.LightDirection4.x  = dot( fvTangent, fvLightDirection4.xyz ); 
   OUT.LightDirection4.y  = dot( fvBinormal, fvLightDirection4.xyz ); 
   OUT.LightDirection4.z  = dot( fvNormal, fvLightDirection4.xyz ); 
   
   return OUT;
}
" />
				 <pixel shader=
"float4 fvAmbient;
float4 fvLight1Color; 
float4 fvLight2Color; 
float4 fvLight3Color; 
float4 fvLight4Color; 
float fSpecularPower; 
float fSpecularStrength; 
float fBumpStrength; 
sampler2D baseMap      : register(s0); 
sampler2D bumpMap      : register(s1); 
struct PS_INPUT
{   
   float2 Texcoord            : TEXCOORD0;
   float3 ViewDirection      : TEXCOORD1; 
   float3 LightDirection1      : TEXCOORD2; 
   float3 LightDirection2      : TEXCOORD3;
   float3 LightDirection3      : TEXCOORD4; 
   float3 LightDirection4      : TEXCOORD5; 
   float4 LightDistMultiplier  : TEXCOORD6;
};
float4 pixelMain( in PS_INPUT IN ) : COLOR
{
   float4 color = float4(0,0,0,0);
   float3  fvLightDirection1 = normalize( IN.LightDirection1 ); 
   float3  fvLightDirection2 = normalize( IN.LightDirection2 ); 
   float3  fvLightDirection3 = normalize( IN.LightDirection3 ); 
   float3  fvLightDirection4 = normalize( IN.LightDirection4 ); 
   float3  fvNormal          = tex2D( bumpMap, IN.Texcoord ).yxz; 
   
   fvNormal.xy*=2.0; 
   fvNormal.xy-=1.0;
   fvNormal=(float3(0.0,0.0,1.0)-fvNormal)*fBumpStrength+fvNormal; 
   fvNormal=normalize(fvNormal);
   
   float fNDotL1           = max(dot(fvNormal, fvLightDirection1),0.0)-0.1;  
   float fNDotL2           = max(dot(fvNormal, fvLightDirection2),0.0)-0.1;  
   float fNDotL3           = max(dot(fvNormal, fvLightDirection3),0.0)-0.1;  
   float fNDotL4           = max(dot(fvNormal, fvLightDirection4),0.0)-0.1;  
   float3  fvReflection1     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection1 );  
   float3  fvReflection2     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection2 );  
   float3  fvReflection3     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection3 );  
   float3  fvReflection4     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection4 );  
   float3  fvViewDirection  = normalize( IN.ViewDirection ); 
   float fRDotV1          = max( 0.0, dot( fvReflection1, fvViewDirection ) ); 
   float fRDotV2          = max( 0.0, dot( fvReflection2, fvViewDirection ) ); 
   float fRDotV3          = max( 0.0, dot( fvReflection3, fvViewDirection ) ); 
   float fRDotV4          = max( 0.0, dot( fvReflection4, fvViewDirection ) ); 
   float4  fvBaseColor      = tex2D( baseMap, IN.Texcoord ); 
   float4  fvTotalAmbient   = fvAmbient * fvBaseColor;  
   float4  fvTotalDiffuse   = fvLight1Color * fNDotL1* fvBaseColor*IN.LightDistMultiplier[0];  
   float4  fvTotalSpecular  = fNDotL1*fvLight1Color * ( pow( fRDotV1, fSpecularPower ) )*IN.LightDistMultiplier[0]; 
   fvTotalDiffuse   += fvLight2Color * fNDotL2* fvBaseColor*IN.LightDistMultiplier[1];  
   fvTotalSpecular  += fNDotL2*fvLight2Color * ( pow( fRDotV2, fSpecularPower ) )*IN.LightDistMultiplier[1];   
   fvTotalDiffuse   += fvLight3Color * fNDotL3* fvBaseColor*IN.LightDistMultiplier[2];  
   fvTotalSpecular  += fNDotL3*fvLight3Color * ( pow( fRDotV3, fSpecularPower ) )*IN.LightDistMultiplier[2];   
   fvTotalDiffuse   += fvLight4Color * fNDotL4* fvBaseColor*IN.LightDistMultiplier[3];  
   fvTotalSpecular  += fNDotL4*fvLight4Color * ( pow( fRDotV4, fSpecularPower ) )*IN.LightDistMultiplier[3];   
   color=( fvTotalAmbient + fvTotalDiffuse+ (fvTotalSpecular*fSpecularStrength)); 
   if(color.r>1.0){color.gb+=color.r-1.0;} 
   if(color.g>1.0){color.rb+=color.g-1.0;} 
   if(color.b>1.0){color.rg+=color.b-1.0;} 
   
   return color;
}
" />
				 <constants value="vmatrix4 ModelViewProjectionMatrix proj[0] view[0] world[0] dontMakeInverse
vmatrix4 ModelViewMatrix view[0] world[0] 0 dontMakeInverse
vmatrix4 matWorldInverse world[0] 0 0 makeInverse

vfloat fLightStrength1 2
vfloat fLightStrength2 2
vfloat fLightStrength3 2
vfloat fLightStrength4 2

vvector3df fvLightPosition1 -150 240 -34
vvector3df fvLightPosition2 -150 240 -34
vvector3df fvLightPosition3 150 240 -34
vvector3df fvLightPosition4 150 240 -34

pSColor fvAmbient 1 1 1 1
pSColor fvLight1Color 1 1 1 1
pSColor fvLight2Color 1 1 1 1 
pSColor fvLight3Color 1 1 1 1 
pSColor fvLight4Color 1 1 1 1

pfloat fSpecularPower 20
pfloat fSpecularStrength 0.9
pfloat fBumpStrength 5
" />
			 </materialType>

			 <materialType>
				 <pixelShaderType type="7" /> 
				 <vertexShaderType type="0" /> 
				 <baseMaterial type="0" /> 
				 <name cname="normal_mapping_package_3.spkg" />
				 <vertex shader=
"float4x4 matWorldInverse; 
float4x4 ModelViewMatrix;
float4x4 ModelViewProjectionMatrix;
float3 fvLightPosition1; 
float3 fvLightPosition2; 
float3 fvLightPosition3; 
float3 fvLightPosition4; 
float fLightStrength1; 
float fLightStrength2; 
float fLightStrength3; 
float fLightStrength4; 
struct VS_OUTPUT
{
   float4 Position            : POSITION0;
   float2 Texcoord            : TEXCOORD0;
   float3 ViewDirection      : TEXCOORD1; 
   float3 LightDirection1      : TEXCOORD2; 
   float3 LightDirection2      : TEXCOORD3; 
   float3 LightDirection3      : TEXCOORD4; 
   float3 LightDirection4      : TEXCOORD5; 
   float4 LightDistMultiplier  : TEXCOORD6;
};
float getLengthSQR (float3 vec) 
{ 
   return(vec.x*vec.x+vec.y*vec.y+vec.z*vec.z); 
}  
struct VS_INPUT
{
   float3 Position         : POSITION0;
   float3 Normal           : NORMAL;
   float2 Texcoord         : TEXCOORD0;
};
VS_OUTPUT vertexMain( in VS_INPUT IN ) 
{    
   VS_OUTPUT OUT = (VS_OUTPUT)0;
   OUT.Position = mul(float4(IN.Position,1.0), ModelViewProjectionMatrix);
   OUT.Texcoord = IN.Texcoord;
   
   float4x4 LightTransform= ModelViewMatrix; 
   LightTransform= mul(matWorldInverse, LightTransform);
   float4 fvObjectPosition = mul(float4(IN.Position,1.0), ModelViewProjectionMatrix);
   float4 fvLightPos1 = mul(float4(fvLightPosition1,1.0), LightTransform); 
   float4 fvLightPos2 = mul(float4(fvLightPosition2,1.0), LightTransform); 
   float4 fvLightPos3 = mul(float4(fvLightPosition3,1.0), LightTransform); 
   float4 fvLightPos4 = mul(float4(fvLightPosition4,1.0), LightTransform); 
   float3 fvViewDirection  =  - fvObjectPosition.xyz; 
   float3 fvLightDirection1 = (fvLightPos1.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection2 = (fvLightPos2.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection3 = (fvLightPos3.xyz - fvObjectPosition.xyz); 
   float3 fvLightDirection4 = (fvLightPos4.xyz - fvObjectPosition.xyz); 
   
   OUT.LightDistMultiplier[0]=1.0/(getLengthSQR (fvLightDirection1)/(fLightStrength1*10000.0)); 
   OUT.LightDistMultiplier[1]=1.0/(getLengthSQR (fvLightDirection2)/(fLightStrength2*10000.0)); 
   OUT.LightDistMultiplier[2]=1.0/(getLengthSQR (fvLightDirection3)/(fLightStrength3*10000.0)); 
   OUT.LightDistMultiplier[3]=1.0/(getLengthSQR (fvLightDirection4)/(fLightStrength4*10000.0)); 
   
   float3 fvTangent   = -float3(abs(IN.Normal.y) + abs(IN.Normal.z), abs(IN.Normal.x), 0); 
   float3 fvBinormal   = cross(fvTangent,IN.Normal);
   float3 fvNormal     = mul(IN.Normal, ModelViewMatrix); 
   fvTangent         = mul( cross(fvBinormal, IN.Normal), ModelViewMatrix ); 
   fvBinormal         = mul( fvBinormal, ModelViewMatrix ); 
   
   OUT.ViewDirection.x  = dot( fvTangent, fvViewDirection ); 
   OUT.ViewDirection.y  = dot( fvBinormal, fvViewDirection ); 
   OUT.ViewDirection.z  = dot( fvNormal, fvViewDirection ); 
   OUT.LightDirection1.x  = dot( fvTangent, fvLightDirection1.xyz ); 
   OUT.LightDirection1.y  = dot( fvBinormal, fvLightDirection1.xyz ); 
   OUT.LightDirection1.z  = dot( fvNormal, fvLightDirection1.xyz ); 
   OUT.LightDirection2.x  = dot( fvTangent, fvLightDirection2.xyz ); 
   OUT.LightDirection2.y  = dot( fvBinormal, fvLightDirection2.xyz ); 
   OUT.LightDirection2.z  = dot( fvNormal, fvLightDirection2.xyz ); 
   OUT.LightDirection3.x  = dot( fvTangent, fvLightDirection3.xyz ); 
   OUT.LightDirection3.y  = dot( fvBinormal, fvLightDirection3.xyz ); 
   OUT.LightDirection3.z  = dot( fvNormal, fvLightDirection3.xyz ); 
   OUT.LightDirection4.x  = dot( fvTangent, fvLightDirection4.xyz ); 
   OUT.LightDirection4.y  = dot( fvBinormal, fvLightDirection4.xyz ); 
   OUT.LightDirection4.z  = dot( fvNormal, fvLightDirection4.xyz ); 
   
   return OUT;
}
" />
				 <pixel shader=
"float4 fvAmbient;
float4 fvLight1Color; 
float4 fvLight2Color; 
float4 fvLight3Color; 
float4 fvLight4Color; 
float fSpecularPower; 
float fSpecularStrength; 
float fBumpStrength; 
sampler2D baseMap      : register(s0); 
sampler2D bumpMap      : register(s2);
struct PS_INPUT
{   
   float2 Texcoord            : TEXCOORD0;
   float3 ViewDirection      : TEXCOORD1; 
   float3 LightDirection1      : TEXCOORD2; 
   float3 LightDirection2      : TEXCOORD3;
   float3 LightDirection3      : TEXCOORD4; 
   float3 LightDirection4      : TEXCOORD5; 
   float4 LightDistMultiplier  : TEXCOORD6;
};
float4 pixelMain( in PS_INPUT IN ) : COLOR
{
   float4 color = float4(0,0,0,0);
   float3  fvLightDirection1 = normalize( IN.LightDirection1 ); 
   float3  fvLightDirection2 = normalize( IN.LightDirection2 ); 
   float3  fvLightDirection3 = normalize( IN.LightDirection3 ); 
   float3  fvLightDirection4 = normalize( IN.LightDirection4 ); 
   float3  fvNormal          = tex2D( bumpMap, IN.Texcoord ).yxz; 
   
   fvNormal.xy*=2.0; 
   fvNormal.xy-=1.0;
   fvNormal=(float3(0.0,0.0,1.0)-fvNormal)*fBumpStrength+fvNormal; 
   fvNormal=normalize(fvNormal);
   
   float fNDotL1           = max(dot(fvNormal, fvLightDirection1),0.0)-0.1;  
   float fNDotL2           = max(dot(fvNormal, fvLightDirection2),0.0)-0.1;  
   float fNDotL3           = max(dot(fvNormal, fvLightDirection3),0.0)-0.1;  
   float fNDotL4           = max(dot(fvNormal, fvLightDirection4),0.0)-0.1;  
   float3  fvReflection1     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection1 );  
   float3  fvReflection2     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection2 );  
   float3  fvReflection3     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection3 );  
   float3  fvReflection4     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection4 );  
   float3  fvViewDirection  = normalize( IN.ViewDirection ); 
   float fRDotV1          = max( 0.0, dot( fvReflection1, fvViewDirection ) ); 
   float fRDotV2          = max( 0.0, dot( fvReflection2, fvViewDirection ) ); 
   float fRDotV3          = max( 0.0, dot( fvReflection3, fvViewDirection ) ); 
   float fRDotV4          = max( 0.0, dot( fvReflection4, fvViewDirection ) ); 
   float4  fvBaseColor      = tex2D( baseMap, IN.Texcoord ); 
   float4  fvTotalAmbient   = fvAmbient * fvBaseColor;  
   float4  fvTotalDiffuse   = fvLight1Color * fNDotL1* fvBaseColor*IN.LightDistMultiplier[0];  
   float4  fvTotalSpecular  = fNDotL1*fvLight1Color * ( pow( fRDotV1, fSpecularPower ) )*IN.LightDistMultiplier[0]; 
   fvTotalDiffuse   += fvLight2Color * fNDotL2* fvBaseColor*IN.LightDistMultiplier[1];  
   fvTotalSpecular  += fNDotL2*fvLight2Color * ( pow( fRDotV2, fSpecularPower ) )*IN.LightDistMultiplier[1];   
   fvTotalDiffuse   += fvLight3Color * fNDotL3* fvBaseColor*IN.LightDistMultiplier[2];  
   fvTotalSpecular  += fNDotL3*fvLight3Color * ( pow( fRDotV3, fSpecularPower ) )*IN.LightDistMultiplier[2];   
   fvTotalDiffuse   += fvLight4Color * fNDotL4* fvBaseColor*IN.LightDistMultiplier[3];  
   fvTotalSpecular  += fNDotL4*fvLight4Color * ( pow( fRDotV4, fSpecularPower ) )*IN.LightDistMultiplier[3];   
   color=( fvTotalAmbient + fvTotalDiffuse+ (fvTotalSpecular*fSpecularStrength)); 
   if(color.r>1.0){color.gb+=color.r-1.0;} 
   if(color.g>1.0){color.rb+=color.g-1.0;} 
   if(color.b>1.0){color.rg+=color.b-1.0;} 
   
   return color;
}
" />
				 <constants value="vmatrix4 ModelViewProjectionMatrix proj[0] view[0] world[0] dontMakeInverse
vmatrix4 ModelViewMatrix view[0] world[0] 0 dontMakeInverse
vmatrix4 matWorldInverse world[0] 0 0 makeInverse

vfloat fLightStrength1 2
vfloat fLightStrength2 2
vfloat fLightStrength3 2
vfloat fLightStrength4 2

vvector3df fvLightPosition1 -150 240 -34
vvector3df fvLightPosition2 -150 240 -34
vvector3df fvLightPosition3 150 240 -34
vvector3df fvLightPosition4 150 240 -34

pSColor fvAmbient 1 1 1 1
pSColor fvLight1Color 1 1 1 1
pSColor fvLight2Color 1 1 1 1 
pSColor fvLight3Color 1 1 1 1 
pSColor fvLight4Color 1 1 1 1

pfloat fSpecularPower 20
pfloat fSpecularStrength 0.9
pfloat fBumpStrength 15
" />
			 </materialType>

			 <materialType>
				 <pixelShaderType type="7" /> 
				 <vertexShaderType type="3" /> 
				 <baseMaterial type="0" /> 
				 <name cname="grass_shader.spkg" />
				 <vertex shader=
"uniform float4x4 worldViewProj;

uniform float4x4 mWorld;

uniform float3 eyePositionO;

uniform float3 LightPos;

uniform float time; //Runs from 0 to 10 per second.



#define PPLighting



void vertexMain(



    float4 position    : POSITION,

    float3 normal    : NORMAL,

    

    float2 texCoord     : TEXCOORD0,

    float3 tangent : TEXCOORD1,



    float4 vertColor : COLOR, //In this implementation a per vertex lightmap is used



    out float4 oVertColor          : COLOR,

    out float2 oTexCoord          : TEXCOORD0,

    out float2 oTexCoord2          : TEXCOORD1,

    out float4 oPosition           : POSITION,

    out float3 oEyeDirTan          : TEXCOORD2,

    out float4 oPositionViewProj    : TEXCOORD3

    #ifdef PPLighting

        ,out float3 oLightDir    : TEXCOORD4,

        out float3 oNormal    : TEXCOORD5

    #endif

)

{

    oPosition = mul(position, worldViewProj); //oPosition must be output to satisy pipeline.

    oPositionViewProj = oPosition;



    oTexCoord = texCoord;

    oTexCoord2 = float2((texCoord.x+time*0.2)/2,(texCoord.y+time*0.2)/2); // offset second texture coordinate

                                        // according to time for wind texture



    oVertColor = vertColor;

    

    float3 posWorld = mul(position, mWorld);

    float3 eyeDirO = normalize(-(eyePositionO-posWorld)) ; //eye vector in object space

    

    #ifdef PPLighting

    oLightDir = normalize(LightPos-posWorld);

    oNormal = normal;

    #endif

    

    // Using mesh-defined tangents. (Uncomment section to calculate them ourselves.)

    tangent = float3(abs(normal.y) + abs(normal.z),abs(normal.x),0);

    

    float3 binormal = cross(tangent,normal);

    float3x3 TBNMatrix = float3x3(tangent,binormal,normal); 



    oEyeDirTan = normalize(mul(eyeDirO,TBNMatrix)); // eye vector in tangent space

}



#define MAX_RAYDEPTH 9 //Number of iterations.



#define PLANE_NUM 32.0 //Number of grass slice grid planes per unit in tangent space.



#define PLANE_NUM_INV (1.0/PLANE_NUM)

#define PLANE_NUM_INV_DIV2 (PLANE_NUM_INV/2)



#define GRASS_SLICE_NUM 16 // Number of grass slices in texture grassblades.



#define GRASS_SLICE_NUM_INV (1.0/GRASS_SLICE_NUM)

#define GRASS_SLICE_NUM_INV_DIV2 (GRASS_SLICE_NUM_INV/2)



#define GRASSDEPTH GRASS_SLICE_NUM_INV //Depth set to inverse of number of grass slices so no stretching occurs.



#define TC1_TO_TC2_RATIO 8 //Ratio of texture coordinate set 1 to texture coordinate set 2, used for the animation lookup.



#define PREMULT (GRASS_SLICE_NUM_INV*PLANE_NUM) //Saves a multiply in the shader.



#define AVERAGE_COLOR float4(0.32156,0.513725,0.0941176,1.0) //Used to fill remaining opacity, can be replaced by a texture lookup.



sampler2D grassblades : register(s0);

sampler2D ground : register(s2);

sampler2D windnoise : register(s3);



void  pixelMain(



    in float4 vertColor      : COLOR,

    

    in float2 texCoord           : TEXCOORD0,

    in float2 texCoord2          : TEXCOORD1,

    in float3 eyeDirTan          : TEXCOORD2,

    in float4 positionViewProj  : TEXCOORD3,

    #ifdef PPLighting

    in float3 LightDir    : TEXCOORD4,

    in float3 Normal    : TEXCOORD5,

    #endif

    

    out float4 color    : COLOR

    ,out float depth        : DEPTH)

{    

    

    //Initialize increments/decrements and per fragment constants

    color = float4(0.0,0.0,0.0,0.0);



    float2 plane_offset = float2(0.0,0.0);                    

    float3 rayEntry = float3(texCoord.xy,0.0);

    float zOffset = 0.0;

    bool zFlag = 1;    //The signs of eyeDirTan determines if we increment or decrement along the tangent space axis

    //plane_correct, planemod and pre_dir_correct are used to avoid unneccessary if-conditions. 



     float2 signf = float2(sign(eyeDirTan.x),sign(eyeDirTan.y));    

     float2 plane_correct = float2((signf.x+1)*GRASS_SLICE_NUM_INV_DIV2,

                                   (signf.y+1)*GRASS_SLICE_NUM_INV_DIV2);

     float2 planemod = float2(floor(rayEntry.x*PLANE_NUM)/PLANE_NUM,

                              floor(rayEntry.y*PLANE_NUM)/PLANE_NUM);

    

    



    float2 pre_dir_correct = float2((signf.x+1)*PLANE_NUM_INV_DIV2,

                                    (signf.y+1)*PLANE_NUM_INV_DIV2);

                                    

    int hitcount;

    

    float2 orthoLookup; //Will contain texture lookup coordinates for grassblades texture.

        for(hitcount =0; hitcount < MAX_RAYDEPTH ; hitcount++) // %([MAX_RAYDEPTH]+1) speeds up compilation.

                                     // It may prove to be faster to early exit this loop

                                         // depending on the hardware used.

    {



        //Calculate positions of the intersections with the next grid planes on the u,v tangent space axis independently.



            float2 dir_correct = float2(signf.x*plane_offset.x+pre_dir_correct.x,

                                        signf.y*plane_offset.y+pre_dir_correct.y);            

        float2 distance = float2((planemod.x + dir_correct.x - rayEntry.x)/(eyeDirTan.x),

                                 (planemod.y + dir_correct.y - rayEntry.y)/(eyeDirTan.y));

                     

         float3 rayHitpointX = rayEntry + eyeDirTan *distance.x;   

          float3 rayHitpointY = rayEntry + eyeDirTan *distance.y;

        

        //Check if we hit the ground. If so, calculate the intersection and look up the ground texture and blend colors.

    

          if ((rayHitpointX.z <= -GRASSDEPTH)&& (rayHitpointY.z <= -GRASSDEPTH))     

          {

              float distanceZ = (-GRASSDEPTH)/eyeDirTan.z; // rayEntry.z is 0.0 anyway 

    

              float3 rayHitpointZ = rayEntry + eyeDirTan *distanceZ;

            float2 orthoLookupZ = float2(rayHitpointZ.x,rayHitpointZ.y);

                        

              color = (color)+((1.0-color.w) * tex2D(ground,orthoLookupZ));

              if(zFlag ==1) 

            zOffset = distanceZ; // write the distance from rayEntry to intersection

              zFlag = 0; //Early exit here if faster.        

          }  

          else

         {

             

             

    

             //check if we hit a u or v plane, calculate lookup accordingly with wind shear displacement.

            if(distance.x <= distance.y)

             {

                 float4 windX = (tex2D(windnoise,texCoord2+rayHitpointX.xy/TC1_TO_TC2_RATIO)-0.5)/2;

                

                float lookupX = -(rayHitpointX.z+(planemod.x+signf.x*plane_offset.x)*PREMULT)-plane_correct.x;

                orthoLookup=float2(rayHitpointX.y+windX.x*(GRASSDEPTH+rayHitpointX.z),lookupX); 

                

                plane_offset.x += PLANE_NUM_INV; // increment/decrement to next grid plane on u axis

                if(zFlag==1) zOffset = distance.x;

            }

            else {

                float4 windY = (tex2D(windnoise,texCoord2+rayHitpointY.xy/TC1_TO_TC2_RATIO)-0.5)/2;

             

                float lookupY = -(rayHitpointY.z+(planemod.y+signf.y*plane_offset.y)*PREMULT)-plane_correct.y;

                orthoLookup = float2(rayHitpointY.x+windY.y*(GRASSDEPTH+rayHitpointY.z) ,lookupY);

             

                plane_offset.y += PLANE_NUM_INV;  // increment/decrement to next grid plane on v axis

                if(zFlag==1) zOffset = distance.y;



    float4 biased;

         biased.xy = orthoLookup;

         biased.z = 0;

         biased.w = -100.0;

            

           color += (1.0-color.w)*tex2Dbias(grassblades,biased);//orthoLookup)

                    

              }

               

                 color += (1.0-color.w)*tex2D(grassblades,orthoLookup);

     

                 if(color.w >= 0.49)

            {zFlag = 0;}    //Early exit here if faster.

          }

    }    

    

        color += (1.0-color.w)*tex2D(ground,orthoLookup);     //Fill remaining transparency in case there is some left. Can be replaced by a texture lookup

                                            //into a fully opaque grass slice using orthoLookup.

        

        

        //color.xyz *= (vertColor.xyz);     //Modulate with per vertex lightmap,as an alternative, modulate with N*L for dynamic lighting.

    

    #ifdef PPLighting

        color.xyz *= dot(LightDir,Normal);

    #endif

     

        //zOffset is along eye direction, transform and add to vertex position to get correct z-value.

       // BlindSide NOTE: Commented this section out as it causes a bug.

     positionViewProj += mul(eyeDirTan.xzy*zOffset,worldViewProj); 

    

       //Divide by homogenous part.

      depth = positionViewProj.z / positionViewProj.w;

    

     //color.xyz = depth;

}

" />
				 <pixel shader=
"uniform float4x4 worldViewProj;

uniform float4x4 mWorld;

uniform float3 eyePositionO;

uniform float3 LightPos;

uniform float time; //Runs from 0 to 10 per second.



#define PPLighting



void vertexMain(



    float4 position    : POSITION,

    float3 normal    : NORMAL,

    

    float2 texCoord     : TEXCOORD0,

    float3 tangent : TEXCOORD1,



    float4 vertColor : COLOR, //In this implementation a per vertex lightmap is used



    out float4 oVertColor          : COLOR,

    out float2 oTexCoord          : TEXCOORD0,

    out float2 oTexCoord2          : TEXCOORD1,

    out float4 oPosition           : POSITION,

    out float3 oEyeDirTan          : TEXCOORD2,

    out float4 oPositionViewProj    : TEXCOORD3

    #ifdef PPLighting

        ,out float3 oLightDir    : TEXCOORD4,

        out float3 oNormal    : TEXCOORD5

    #endif

)

{

    oPosition = mul(position, worldViewProj); //oPosition must be output to satisy pipeline.

    oPositionViewProj = oPosition;



    oTexCoord = texCoord;

    oTexCoord2 = float2((texCoord.x+time*0.2)/2,(texCoord.y+time*0.2)/2); // offset second texture coordinate

                                        // according to time for wind texture



    oVertColor = vertColor;

    

    float3 posWorld = mul(position, mWorld);

    float3 eyeDirO = normalize(-(eyePositionO-posWorld)) ; //eye vector in object space

    

    #ifdef PPLighting

    oLightDir = normalize(LightPos-posWorld);

    oNormal = normal;

    #endif

    

    // Using mesh-defined tangents. (Uncomment section to calculate them ourselves.)

    tangent = float3(abs(normal.y) + abs(normal.z),abs(normal.x),0);

    

    float3 binormal = cross(tangent,normal);

    float3x3 TBNMatrix = float3x3(tangent,binormal,normal); 



    oEyeDirTan = normalize(mul(eyeDirO,TBNMatrix)); // eye vector in tangent space

}



#define MAX_RAYDEPTH 9 //Number of iterations.



#define PLANE_NUM 32.0 //Number of grass slice grid planes per unit in tangent space.



#define PLANE_NUM_INV (1.0/PLANE_NUM)

#define PLANE_NUM_INV_DIV2 (PLANE_NUM_INV/2)



#define GRASS_SLICE_NUM 16 // Number of grass slices in texture grassblades.



#define GRASS_SLICE_NUM_INV (1.0/GRASS_SLICE_NUM)

#define GRASS_SLICE_NUM_INV_DIV2 (GRASS_SLICE_NUM_INV/2)



#define GRASSDEPTH GRASS_SLICE_NUM_INV //Depth set to inverse of number of grass slices so no stretching occurs.



#define TC1_TO_TC2_RATIO 8 //Ratio of texture coordinate set 1 to texture coordinate set 2, used for the animation lookup.



#define PREMULT (GRASS_SLICE_NUM_INV*PLANE_NUM) //Saves a multiply in the shader.



#define AVERAGE_COLOR float4(0.32156,0.513725,0.0941176,1.0) //Used to fill remaining opacity, can be replaced by a texture lookup.



sampler2D grassblades : register(s0);

sampler2D ground : register(s2);

sampler2D windnoise : register(s3);



void  pixelMain(



    in float4 vertColor      : COLOR,

    

    in float2 texCoord           : TEXCOORD0,

    in float2 texCoord2          : TEXCOORD1,

    in float3 eyeDirTan          : TEXCOORD2,

    in float4 positionViewProj  : TEXCOORD3,

    #ifdef PPLighting

    in float3 LightDir    : TEXCOORD4,

    in float3 Normal    : TEXCOORD5,

    #endif

    

    out float4 color    : COLOR

    ,out float depth        : DEPTH)

{    

    

    //Initialize increments/decrements and per fragment constants

    color = float4(0.0,0.0,0.0,0.0);



    float2 plane_offset = float2(0.0,0.0);                    

    float3 rayEntry = float3(texCoord.xy,0.0);

    float zOffset = 0.0;

    bool zFlag = 1;    //The signs of eyeDirTan determines if we increment or decrement along the tangent space axis

    //plane_correct, planemod and pre_dir_correct are used to avoid unneccessary if-conditions. 



     float2 signf = float2(sign(eyeDirTan.x),sign(eyeDirTan.y));    

     float2 plane_correct = float2((signf.x+1)*GRASS_SLICE_NUM_INV_DIV2,

                                   (signf.y+1)*GRASS_SLICE_NUM_INV_DIV2);

     float2 planemod = float2(floor(rayEntry.x*PLANE_NUM)/PLANE_NUM,

                              floor(rayEntry.y*PLANE_NUM)/PLANE_NUM);

    

    



    float2 pre_dir_correct = float2((signf.x+1)*PLANE_NUM_INV_DIV2,

                                    (signf.y+1)*PLANE_NUM_INV_DIV2);

                                    

    int hitcount;

    

    float2 orthoLookup; //Will contain texture lookup coordinates for grassblades texture.

        for(hitcount =0; hitcount < MAX_RAYDEPTH ; hitcount++) // %([MAX_RAYDEPTH]+1) speeds up compilation.

                                     // It may prove to be faster to early exit this loop

                                         // depending on the hardware used.

    {



        //Calculate positions of the intersections with the next grid planes on the u,v tangent space axis independently.



            float2 dir_correct = float2(signf.x*plane_offset.x+pre_dir_correct.x,

                                        signf.y*plane_offset.y+pre_dir_correct.y);            

        float2 distance = float2((planemod.x + dir_correct.x - rayEntry.x)/(eyeDirTan.x),

                                 (planemod.y + dir_correct.y - rayEntry.y)/(eyeDirTan.y));

                     

         float3 rayHitpointX = rayEntry + eyeDirTan *distance.x;   

          float3 rayHitpointY = rayEntry + eyeDirTan *distance.y;

        

        //Check if we hit the ground. If so, calculate the intersection and look up the ground texture and blend colors.

    

          if ((rayHitpointX.z <= -GRASSDEPTH)&& (rayHitpointY.z <= -GRASSDEPTH))     

          {

              float distanceZ = (-GRASSDEPTH)/eyeDirTan.z; // rayEntry.z is 0.0 anyway 

    

              float3 rayHitpointZ = rayEntry + eyeDirTan *distanceZ;

            float2 orthoLookupZ = float2(rayHitpointZ.x,rayHitpointZ.y);

                        

              color = (color)+((1.0-color.w) * tex2D(ground,orthoLookupZ));

              if(zFlag ==1) 

            zOffset = distanceZ; // write the distance from rayEntry to intersection

              zFlag = 0; //Early exit here if faster.        

          }  

          else

         {

             

             

    

             //check if we hit a u or v plane, calculate lookup accordingly with wind shear displacement.

            if(distance.x <= distance.y)

             {

                 float4 windX = (tex2D(windnoise,texCoord2+rayHitpointX.xy/TC1_TO_TC2_RATIO)-0.5)/2;

                

                float lookupX = -(rayHitpointX.z+(planemod.x+signf.x*plane_offset.x)*PREMULT)-plane_correct.x;

                orthoLookup=float2(rayHitpointX.y+windX.x*(GRASSDEPTH+rayHitpointX.z),lookupX); 

                

                plane_offset.x += PLANE_NUM_INV; // increment/decrement to next grid plane on u axis

                if(zFlag==1) zOffset = distance.x;

            }

            else {

                float4 windY = (tex2D(windnoise,texCoord2+rayHitpointY.xy/TC1_TO_TC2_RATIO)-0.5)/2;

             

                float lookupY = -(rayHitpointY.z+(planemod.y+signf.y*plane_offset.y)*PREMULT)-plane_correct.y;

                orthoLookup = float2(rayHitpointY.x+windY.y*(GRASSDEPTH+rayHitpointY.z) ,lookupY);

             

                plane_offset.y += PLANE_NUM_INV;  // increment/decrement to next grid plane on v axis

                if(zFlag==1) zOffset = distance.y;



    float4 biased;

         biased.xy = orthoLookup;

         biased.z = 0;

         biased.w = -100.0;

            

           color += (1.0-color.w)*tex2Dbias(grassblades,biased);//orthoLookup)

                    

              }

               

                 color += (1.0-color.w)*tex2D(grassblades,orthoLookup);

     

                 if(color.w >= 0.49)

            {zFlag = 0;}    //Early exit here if faster.

          }

    }    

    

        color += (1.0-color.w)*tex2D(ground,orthoLookup);     //Fill remaining transparency in case there is some left. Can be replaced by a texture lookup

                                            //into a fully opaque grass slice using orthoLookup.

        

        

        //color.xyz *= (vertColor.xyz);     //Modulate with per vertex lightmap,as an alternative, modulate with N*L for dynamic lighting.

    

    #ifdef PPLighting

        color.xyz *= dot(LightDir,Normal);

    #endif

     

        //zOffset is along eye direction, transform and add to vertex position to get correct z-value.

       // BlindSide NOTE: Commented this section out as it causes a bug.

     positionViewProj += mul(eyeDirTan.xzy*zOffset,worldViewProj); 

    

       //Divide by homogenous part.

      depth = positionViewProj.z / positionViewProj.w;

    

     //color.xyz = depth;

}

" />
				 <constants value="vmatrix4 worldViewProj proj[0] view[0] world[0] 0

vmatrix4 mWorld world[0] 0 0 0

vvector3df eyePositionO camPos4

vvector3df LightPos 308 455 343

vfloat time + ctime 1000

" />
			 </materialType>

			 <materialType>
				 <pixelShaderType type="0" /> 
				 <vertexShaderType type="0" /> 
				 <baseMaterial type="0" /> 
				 <name cname="skybox" />
				 <vertex shader=
"float4x4 worldViewProj;

struct VertexShaderOutput {
    float4 Position : POSITION0;
    float4 TexCoords : TEXCOORD0;
};
struct VertexShaderInput {
    float4 Position : POSITION0;
    float4 TexCoords : TEXCOORD0;
};

VertexShaderOutput vertexMain(VertexShaderInput input) {
    VertexShaderOutput output = (VertexShaderOutput)0;
    
    output.Position = mul(input.Position, worldViewProj);
    output.TexCoords = input.TexCoords;
    
    return output;
}
" />
				 <pixel shader=
"sampler2D DiffuseSampler : register(s0);
sampler2D HDRSampler : register(s1);

float4x4 worldViewProj;

struct VertexShaderOutput {
    float4 Position : POSITION0;
    float4 TexCoords : TEXCOORD0;
};

float4 pixelMain(VertexShaderOutput input) : COLOR0 {
    float4 color = tex2D(DiffuseSampler, input.TexCoords);
    color.b = 0.0;
    color.r *= tex2D(HDRSampler, input.TexCoords);
    color.g = color.r / 2.0;
    
    return color;
}
" />
				 <constants value="vmatrix4 worldViewProj proj[0] view[0] world[0] 0
" />
			 </materialType>


		 </materialTypes>

		 <scripts>


		 </scripts>

		 <physics>
			 <gravity X="0.000000" Y="-29.000000" Z="0.000000" />
		 </physics>

	</config>



	<scene>

		 <terrain>

			 <path file="C:/Users/julienmoreau-mathis/Desktop/Soganatsu/SSWE/data/statu_lowpoly/statu_lowpoly.obj" />

			 <type esnt="mesh" tangents="0" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="0" />
				 <planarMappedValue value="0.000000" />
				 </planarMapping>

			 </factory> 

			 <name c8name="#map:myName" />

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="data/statu_lowpoly/Ground.jpg" />
						 <texture id="1" path="height_maps/rockn.png" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="0" g="0" b="0" a="255" />
					 <specularColor r="127" g="127" b="127" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="12.298039" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 	 <material id="1">
					 <textures>
						 <texture id="0" path="data/statu_lowpoly/Statu_texture.jpg" />
						 <texture id="1" path="height_maps/rockn.png" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="0" g="0" b="0" a="255" />
					 <specularColor r="127" g="127" b="127" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="12.298039" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="-16.008873" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="24.840839" Y="24.840839" Z="24.840839" />

			<depthPassed value="1" />
			<lightScatteringPassed value="1" />

			 <visible bool="1" />
			 <shadowMode mode="2" />
			 <physics>
			 	 <body type="1">
			 		 <mass value="0.000000" />
			 	 </body>
			 </physics>


		 </terrain>

		 <object>

			 <path file="cube" />

			 <name c8name="#object:new_cube" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="1" />
				 <planarMappedValue value="0.100000" />
				 </planarMapping>

			 </factory> 

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="data/statu_lowpoly/Ground.jpg" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-4" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="0.000000" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="12.699509" Y="0.010000" Z="12.009387" />

			<depthPassed value="1" />
			<lightScatteringPassed value="0" />

			 <visible bool="0" />
			 <shadowMode mode="2" />
			 <actions>
			 </actions>

			 <physics>
			 	 <body type="1">
			 		 <mass value="0.000000" />
			 	 </body>
			 </physics>

		 </object>

		 <object>

			 <path file="hillPlaneMesh" />

			 <name c8name="#object:new_hille_plane_mesh" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="1" />
				 <planarMappedValue value="0.010000" />
				 </planarMapping>

			 </factory> 

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="height_maps/grass/s_grassblades.tga" />
						 <texture id="1" path="" />
						 <texture id="2" path="height_maps/grass/s_grass_ground.tga" />
						 <texture id="3" path="height_maps/grass/windnoise.tga" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-3" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="0.000000" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="1.000000" Y="1.000000" Z="1.000000" />

			<depthPassed value="1" />
			<lightScatteringPassed value="0" />

			 <visible bool="1" />
			 <shadowMode mode="0" />
			 <actions>
			 </actions>

			 <physics>
			 	 <body type="0">
			 	 </body>
			 </physics>

		 </object>

		 <object>

			 <path file="C:/Users/julienmoreau-mathis/Desktop/Soganatsu/SSWE/data/architecture/garden/big_dragon/dragon_crash.x" />

			 <name c8name="#object:dragon" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="0" />
				 <planarMappedValue value="0.000000" />
				 </planarMapping>

			 </factory> 

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="data/architecture/garden/big_dragon/intro flyby crash.fbm/t_dragon_body_d.jpg" />
						 <texture id="1" path="data/architecture/garden/big_dragon/intro flyby crash.fbm/t_dragon_body_n.jpg" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="119" g="119" b="119" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="119" g="119" b="119" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="255" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="0" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 	 <material id="1">
					 <textures>
						 <texture id="0" path="data/architecture/garden/big_dragon/intro flyby crash.fbm/t_dragon_head_d.jpg" />
						 <texture id="1" path="data/architecture/garden/big_dragon/intro flyby crash.fbm/t_dragon_head_n.jpg" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="204" g="204" b="204" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="255" />

					 <lighting value="1" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 	 <material id="2">
					 <textures>
						 <texture id="0" path="data/architecture/garden/big_dragon/intro flyby crash.fbm/t_dragon_head_d.jpg" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="204" g="204" b="204" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="255" />

					 <lighting value="1" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="62.288193" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 	 <material id="3">
					 <textures>
						 <texture id="0" path="data/architecture/garden/big_dragon/intro flyby crash.fbm/t_dragon_body_d.jpg" />
						 <texture id="1" path="data/architecture/garden/big_dragon/intro flyby crash.fbm/t_dragon_body_n.jpg" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="204" g="204" b="204" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="255" />

					 <lighting value="1" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 </materials>
			 <position X="134.462753" Y="22.902126" Z="-11.606293" />
			 <rotation X="0.000000" Y="145.205063" Z="0.000000" />
			 <scale X="0.100000" Y="0.100000" Z="0.100000" />

			<depthPassed value="1" />
			<lightScatteringPassed value="1" />

			 <visible bool="1" />
			 <shadowMode mode="2" />
			 <actions>
				 <action start="38239" end="0" name="CRASH" speed="3000.000000" animPath="Current" /> 

				 <action start="0" end="41440" name="BOSS" speed="3000.000000" animPath="C:/Users/julienmoreau-mathis/Desktop/Soganatsu/SSWE/data/architecture/garden/big_dragon/dragon_eatboss.x" /> 

				 <action start="0" end="30560" name="GRAB" speed="3000.000000" animPath="C:/Users/julienmoreau-mathis/Desktop/Soganatsu/SSWE/data/architecture/garden/big_dragon/dragon_grab.x" /> 

			 </actions>

			 <physics>
			 	 <body type="0">
			 	 </body>
			 </physics>

		 </object>

		 <object>

			 <path file="cube" />

			 <name c8name="#object:new_cube" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="0" />
				 <planarMappedValue value="0.000000" />
				 </planarMapping>

			 </factory> 

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="height_maps/rock.png" />
						 <texture id="1" path="height_maps/rockn.png" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 </materials>
			 <position X="175.857819" Y="0.000000" Z="-88.929108" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="3.744972" Y="1.000000" Z="3.879330" />

			<depthPassed value="1" />
			<lightScatteringPassed value="1" />

			 <visible bool="0" />
			 <shadowMode mode="2" />
			 <actions>
			 </actions>

			 <physics>
			 	 <body type="0">
			 	 </body>
			 </physics>

		 </object>

		 <object>

			 <path file="C:/Users/julienmoreau-mathis/Desktop/Soganatsu/SSWE/data/architecture/garden/stones/rock1/rock1.obj" />

			 <name c8name="#object:myName" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="0" />
				 <planarMappedValue value="0.000000" />
				 </planarMapping>

			 </factory> 

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="data/architecture/garden/stones/rock1/Rock-Texture-Surface.jpg" />
						 <texture id="1" path="height_maps/rockn.png" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="0" g="0" b="0" a="255" />
					 <specularColor r="2" g="2" b="2" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="1.756863" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 	 <material id="1">
					 <textures>
						 <texture id="0" path="" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="0" g="0" b="0" a="255" />
					 <specularColor r="127" g="127" b="127" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="12.298039" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="1" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-4" />

			 	 </material>
			 </materials>
			 <position X="163.608200" Y="-53.924725" Z="-58.669525" />
			 <rotation X="0.000000" Y="91.577728" Z="0.000000" />
			 <scale X="60.599998" Y="60.599998" Z="60.599998" />

			<depthPassed value="1" />
			<lightScatteringPassed value="1" />

			 <visible bool="1" />
			 <shadowMode mode="2" />
			 <actions>
			 </actions>

			 <physics>
			 	 <body type="0">
			 	 </body>
			 </physics>

		 </object>

		 <light>

			 <name c8name="#light:new_light" />

			 <position X="162.574219" Y="270.301941" Z="-190.313446" />
			 <target X="41.010681" Y="332.919983" Z="0.000000" />

			 <diffuseColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />
			 <ambiantColor r="0.000000" g="0.000000" b="0.000000" a="1.000000" />
			 <specularColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />

			 <radius value="20000.000000" />
			 <farValue value="1000.000000" />
			 <autoRecalculate value="1" />

			 <shadows resol="1024" />

			 <lensFlare>
				 <mesh> 
					 <scale X="0.000000" Y="0.000000" Z="0.000000" />
					 <texture path="" />
				 </mesh> 
				 <bill> 
					 <size Width="62.000000" Height="62.000000" />
					 <texture path="shaders/textures/lf/sun.png" />
				 </bill> 
				 <lfsn> 
					 <strength value="1000.000000" />
					 <texture path="" />
					 <falseOcclusion value="0" />
				 </lfsn> 
				 <position X="0.000000" Y="0.000000" Z="0.000000" />
 			 </lensFlare>

		 </light>

		 <skybox>

			 <texture path="data/Lights/glacier_ft.png" />
			 <texture path="data/Lights/glacier_lf.png" />
			 <texture path="data/Lights/glacier_bk.png" />
			 <texture path="data/Lights/glacier_rt.png" />
			 <texture path="data/Lights/glacier_up.png" />
			 <texture path="data/Lights/glacier_dn.png" />
		 </skybox>


	</scene>

</rootScene>
