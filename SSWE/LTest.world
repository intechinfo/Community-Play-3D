<<<<<<< HEAD
<?xml version="1.0"?>

<rootScene>

	<config>

		 <numberOfObjects value="4" />

		 <grid>

			 <accentLineOffset ALO="8" />
			 <size S="1024" />
			 <spacing SP="8" />

		 </grid>

		 <camera>

			 <position X="145.257812" Y="39.333733" Z="168.842926" />
			 <rotation X="337.085449" Y="211.428955" Z="0.000000" />

		 </camera>

		 <fpsCameraSettings>

			 <ellipsoidRadius X="30.000000" Y="60.000000" Z="30.000000" />
			 <gravityPerSecond X="0.000000" Y="-10.000000" Z="0.000000" />
			 <ellipsoidTranslation X="0.000000" Y="0.000000" Z="0.000000" />
			 <slidingValue value="0.000500" />

		 </fpsCameraSettings>

		 <effect>


		 </effect>

		 <materialTypes>

			 <materialType>
				 <pixelShaderType type="0" /> 
				 <vertexShaderType type="0" /> 
				 <baseMaterial type="0" /> 
				 <name cname="nmapping.spkg" />
				 <vertex shader=
"   
void main( void )
{
   gl_Position = ftransform();
}


" />
				 <pixel shader=
"
void main( void )
{
   gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);

}


" />
				 <constants value="


" />
			 </materialType>


		 </materialTypes>

		 <scripts>


		 </scripts>

	</config>



	<scene>

		 <object>

			 <path file="hillPlaneMesh" />

			 <name c8name="#object:new_hille_plane_mesh" />

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="data/Architecture/Beach/Beach/tex/T_Ground.jpg" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="0" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="0.000000" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="1.000000" Y="1.000000" Z="1.000000" />

			 <visible bool="1" />
			 <shadowMode mode="0" />
			 <actions>
			 </actions>

		 </object>

		 <object>

			 <path file="billboard" />

			 <name c8name="#object:new_bill_board" />

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="shaders/Textures/LF/sun.png" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="12" />

			 	 </material>
			 </materials>
			 <position X="-329.078491" Y="351.000000" Z="-204.232132" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="1.000000" Y="1.000000" Z="1.000000" />

			 <visible bool="1" />
			 <shadowMode mode="3" />
			 <actions>
			 </actions>

		 </object>

		 <object>

			 <path file="/home/parallels/Desktop/Soganatsu/SSWE/data/Trees/k4_treepack1/tree 1a - 1b/tree1a_lod0.obj" />

			 <name c8name="#object:tree" />

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="data/Trees/k4_treepack1/tree 1a - 1b/bark1.tga" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="204" g="204" b="204" a="255" />
					 <ambiantColor r="51" g="51" b="51" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="0" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="0" />

			 	 </material>
			 	 <material id="1">
					 <textures>
						 <texture id="0" path="data/Trees/k4_treepack1/tree 1a - 1b/leafs1.tga" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="204" g="204" b="204" a="255" />
					 <ambiantColor r="51" g="51" b="51" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="0" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="14" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="0.000000" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="9.800000" Y="9.800000" Z="9.800000" />

			 <visible bool="1" />
			 <shadowMode mode="2" />
			 <actions>
			 </actions>

		 </object>

		 <light>

			 <name c8name="#light:1" />

			 <position X="-221.770126" Y="345.000000" Z="-152.450775" />
			 <target X="0.000000" Y="0.000000" Z="0.000000" />

			 <diffuseColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />
			 <ambiantColor r="0.000000" g="0.000000" b="0.000000" a="1.000000" />
			 <specularColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />

			 <radius value="100.000000" />
			 <farValue value="5000.000000" />
			 <autoRecalculate value="0" />

			 <shadows resol="4096" />

			 <lensFlare>
			 </lensFlare>

		 </light>


	</scene>

</rootScene>
=======
<?xml version="1.0"?>

<rootScene>

	<config>

		 <numberOfObjects value="4" />

		 <grid>

			 <accentLineOffset ALO="8" />
			 <size S="1024" />
			 <spacing SP="8" />

		 </grid>

		 <camera>

			 <position X="239.484604" Y="135.231216" Z="217.043457" />
			 <rotation X="19.756840" Y="228.035767" Z="0.000000" />

		 </camera>

		 <fpsCameraSettings>

			 <ellipsoidRadius X="30.000000" Y="35.000000" Z="30.000000" />
			 <gravityPerSecond X="0.000000" Y="-10.000000" Z="0.000000" />
			 <ellipsoidTranslation X="0.000000" Y="0.000000" Z="0.000000" />
			 <slidingValue value="0.000500" />

		 </fpsCameraSettings>

		 <effect>


		 </effect>

		 <materialTypes>

			 <materialType>
				 <pixelShaderType type="7" /> 
				 <vertexShaderType type="3" /> 
				 <baseMaterial type="0" /> 
				 <name cname="Normal Mapping Material" />
				 <vertex shader=
"float4x4 matWorldInverse; 







float4x4 ModelViewMatrix;







float4x4 ModelViewProjectionMatrix;







float3 fvLightPosition1; 







float3 fvLightPosition2; 







float3 fvLightPosition3; 







float3 fvLightPosition4; 







float fLightStrength1; 







float fLightStrength2; 







float fLightStrength3; 







float fLightStrength4; 







struct VS_OUTPUT







{







   float4 Position            : POSITION0;







   float2 Texcoord            : TEXCOORD0;







   float3 ViewDirection      : TEXCOORD1; 







   float3 LightDirection1      : TEXCOORD2; 







   float3 LightDirection2      : TEXCOORD3; 







   float3 LightDirection3      : TEXCOORD4; 







   float3 LightDirection4      : TEXCOORD5; 







   float4 LightDistMultiplier  : TEXCOORD6;







};







float getLengthSQR (float3 vec) 







{ 







   return(vec.x*vec.x+vec.y*vec.y+vec.z*vec.z); 







}  







struct VS_INPUT







{







   float3 Position         : POSITION0;







   float3 Normal           : NORMAL;







   float2 Texcoord         : TEXCOORD0;







};







VS_OUTPUT vertexMain( in VS_INPUT IN ) 







{    







   VS_OUTPUT OUT = (VS_OUTPUT)0;







   OUT.Position = mul(float4(IN.Position,1.0), ModelViewProjectionMatrix);







   OUT.Texcoord = IN.Texcoord;







   







   float4x4 LightTransform= ModelViewMatrix; 







   LightTransform= mul(matWorldInverse, LightTransform);







   float4 fvObjectPosition = mul(float4(IN.Position,1.0), ModelViewProjectionMatrix);







   float4 fvLightPos1 = mul(float4(fvLightPosition1,1.0), LightTransform); 







   float4 fvLightPos2 = mul(float4(fvLightPosition2,1.0), LightTransform); 







   float4 fvLightPos3 = mul(float4(fvLightPosition3,1.0), LightTransform); 







   float4 fvLightPos4 = mul(float4(fvLightPosition4,1.0), LightTransform); 







   float3 fvViewDirection  =  - fvObjectPosition.xyz; 







   float3 fvLightDirection1 = (fvLightPos1.xyz - fvObjectPosition.xyz); 







   float3 fvLightDirection2 = (fvLightPos2.xyz - fvObjectPosition.xyz); 







   float3 fvLightDirection3 = (fvLightPos3.xyz - fvObjectPosition.xyz); 







   float3 fvLightDirection4 = (fvLightPos4.xyz - fvObjectPosition.xyz); 







   







   OUT.LightDistMultiplier[0]=1.0/(getLengthSQR (fvLightDirection1)/(fLightStrength1*10000.0)); 







   OUT.LightDistMultiplier[1]=1.0/(getLengthSQR (fvLightDirection2)/(fLightStrength2*10000.0)); 







   OUT.LightDistMultiplier[2]=1.0/(getLengthSQR (fvLightDirection3)/(fLightStrength3*10000.0)); 







   OUT.LightDistMultiplier[3]=1.0/(getLengthSQR (fvLightDirection4)/(fLightStrength4*10000.0)); 







   







   float3 fvTangent   = -float3(abs(IN.Normal.y) + abs(IN.Normal.z), abs(IN.Normal.x), 0); 







   float3 fvBinormal   = cross(fvTangent,IN.Normal);







   float3 fvNormal     = mul(IN.Normal, ModelViewMatrix); 







   fvTangent         = mul( cross(fvBinormal, IN.Normal), ModelViewMatrix ); 







   fvBinormal         = mul( fvBinormal, ModelViewMatrix ); 







   







   OUT.ViewDirection.x  = dot( fvTangent, fvViewDirection ); 







   OUT.ViewDirection.y  = dot( fvBinormal, fvViewDirection ); 







   OUT.ViewDirection.z  = dot( fvNormal, fvViewDirection ); 







   OUT.LightDirection1.x  = dot( fvTangent, fvLightDirection1.xyz ); 







   OUT.LightDirection1.y  = dot( fvBinormal, fvLightDirection1.xyz ); 







   OUT.LightDirection1.z  = dot( fvNormal, fvLightDirection1.xyz ); 







   OUT.LightDirection2.x  = dot( fvTangent, fvLightDirection2.xyz ); 







   OUT.LightDirection2.y  = dot( fvBinormal, fvLightDirection2.xyz ); 







   OUT.LightDirection2.z  = dot( fvNormal, fvLightDirection2.xyz ); 







   OUT.LightDirection3.x  = dot( fvTangent, fvLightDirection3.xyz ); 







   OUT.LightDirection3.y  = dot( fvBinormal, fvLightDirection3.xyz ); 







   OUT.LightDirection3.z  = dot( fvNormal, fvLightDirection3.xyz ); 







   OUT.LightDirection4.x  = dot( fvTangent, fvLightDirection4.xyz ); 







   OUT.LightDirection4.y  = dot( fvBinormal, fvLightDirection4.xyz ); 







   OUT.LightDirection4.z  = dot( fvNormal, fvLightDirection4.xyz ); 







   







   return OUT;







}







" />
				 <pixel shader=
"float4 fvAmbient;







float4 fvLight1Color; 







float4 fvLight2Color; 







float4 fvLight3Color; 







float4 fvLight4Color; 







float fSpecularPower; 







float fSpecularStrength; 







float fBumpStrength; 







sampler2D baseMap      : register(s0); 







sampler2D bumpMap      : register(s1); 







struct PS_INPUT







{   







   float2 Texcoord            : TEXCOORD0;







   float3 ViewDirection      : TEXCOORD1; 







   float3 LightDirection1      : TEXCOORD2; 







   float3 LightDirection2      : TEXCOORD3;







   float3 LightDirection3      : TEXCOORD4; 







   float3 LightDirection4      : TEXCOORD5; 







   float4 LightDistMultiplier  : TEXCOORD6;







};







float4 pixelMain( in PS_INPUT IN ) : COLOR







{







   float4 color = float4(0,0,0,0);







   float3  fvLightDirection1 = normalize( IN.LightDirection1 ); 







   float3  fvLightDirection2 = normalize( IN.LightDirection2 ); 







   float3  fvLightDirection3 = normalize( IN.LightDirection3 ); 







   float3  fvLightDirection4 = normalize( IN.LightDirection4 ); 







   float3  fvNormal          = tex2D( bumpMap, IN.Texcoord ).yxz; 







   







   fvNormal.xy*=2.0; 







   fvNormal.xy-=1.0;







   fvNormal=(float3(0.0,0.0,1.0)-fvNormal)*fBumpStrength+fvNormal; 







   fvNormal=normalize(fvNormal);







   







   float fNDotL1           = max(dot(fvNormal, fvLightDirection1),0.0)-0.1;  







   float fNDotL2           = max(dot(fvNormal, fvLightDirection2),0.0)-0.1;  







   float fNDotL3           = max(dot(fvNormal, fvLightDirection3),0.0)-0.1;  







   float fNDotL4           = max(dot(fvNormal, fvLightDirection4),0.0)-0.1;  







   float3  fvReflection1     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection1 );  







   float3  fvReflection2     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection2 );  







   float3  fvReflection3     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection3 );  







   float3  fvReflection4     = normalize( ( ( 2.0 * fvNormal )  ) - fvLightDirection4 );  







   float3  fvViewDirection  = normalize( IN.ViewDirection ); 







   float fRDotV1          = max( 0.0, dot( fvReflection1, fvViewDirection ) ); 







   float fRDotV2          = max( 0.0, dot( fvReflection2, fvViewDirection ) ); 







   float fRDotV3          = max( 0.0, dot( fvReflection3, fvViewDirection ) ); 







   float fRDotV4          = max( 0.0, dot( fvReflection4, fvViewDirection ) ); 







   float4  fvBaseColor      = tex2D( baseMap, IN.Texcoord ); 







   float4  fvTotalAmbient   = fvAmbient * fvBaseColor;  







   float4  fvTotalDiffuse   = fvLight1Color * fNDotL1* fvBaseColor*IN.LightDistMultiplier[0];  







   float4  fvTotalSpecular  = fNDotL1*fvLight1Color * ( pow( fRDotV1, fSpecularPower ) )*IN.LightDistMultiplier[0]; 







   fvTotalDiffuse   += fvLight2Color * fNDotL2* fvBaseColor*IN.LightDistMultiplier[1];  







   fvTotalSpecular  += fNDotL2*fvLight2Color * ( pow( fRDotV2, fSpecularPower ) )*IN.LightDistMultiplier[1];   







   fvTotalDiffuse   += fvLight3Color * fNDotL3* fvBaseColor*IN.LightDistMultiplier[2];  







   fvTotalSpecular  += fNDotL3*fvLight3Color * ( pow( fRDotV3, fSpecularPower ) )*IN.LightDistMultiplier[2];   







   fvTotalDiffuse   += fvLight4Color * fNDotL4* fvBaseColor*IN.LightDistMultiplier[3];  







   fvTotalSpecular  += fNDotL4*fvLight4Color * ( pow( fRDotV4, fSpecularPower ) )*IN.LightDistMultiplier[3];   







   color=( fvTotalAmbient + fvTotalDiffuse+ (fvTotalSpecular*fSpecularStrength)); 







   if(color.r>1.0){color.gb+=color.r-1.0;} 







   if(color.g>1.0){color.rb+=color.g-1.0;} 







   if(color.b>1.0){color.rg+=color.b-1.0;} 







   







   return color;







}







" />
				 <constants value="vmatrix4 ModelViewProjectionMatrix proj[0] view[0] world[0] dontMakeInverse







vmatrix4 ModelViewMatrix view[0] world[0] 0 dontMakeInverse







vmatrix4 matWorldInverse world[0] 0 0 makeInverse







vfloat fLightStrength1 80







vfloat fLightStrength2 80







vfloat fLightStrength3 80







vfloat fLightStrength4 80







vvector3df fvLightPosition1 150 240 -34







vvector3df fvLightPosition2 150 240 -34







vvector3df fvLightPosition3 150 240 -34







vvector3df fvLightPosition4 150 240 -34







pSColor fvAmbient 1 0.7 0.7 0.7







pSColor fvLight1Color 1 0.02 0.02 0.02







pSColor fvLight2Color 1 0.02 0.02 0.02







pSColor fvLight3Color 1 0.02 0.02 0.02







pSColor fvLight4Color 1 0.02 0.02 0.02







pfloat fSpecularPower 20







pfloat fSpecularStrength 0.9







pfloat fBumpStrength 5







" />
			 </materialType>

			 <materialType>
				 <pixelShaderType type="7" /> 
				 <vertexShaderType type="3" /> 
				 <baseMaterial type="0" /> 
				 <name cname="Grass Material" />
				 <vertex shader=
"#define PPLighting

uniform float4x4 worldViewProj;
uniform float4x4 mWorld;
uniform float3 eyePositionO;
uniform float3 LightPos;
uniform float time; //Runs from 0 to 10 per second.
void vertexMain(
    float4 position    : POSITION,
    float3 normal    : NORMAL,
    
    float2 texCoord     : TEXCOORD0,
    float3 tangent : TEXCOORD1,
    float4 vertColor : COLOR, //In this implementation a per vertex lightmap is used
    out float4 oVertColor          : COLOR,
    out float2 oTexCoord          : TEXCOORD0,
    out float2 oTexCoord2          : TEXCOORD1,
    out float4 oPosition           : POSITION,
    out float3 oEyeDirTan          : TEXCOORD2,
    out float4 oPositionViewProj    : TEXCOORD3
    #ifdef PPLighting
        ,out float3 oLightDir    : TEXCOORD4,
        out float3 oNormal    : TEXCOORD5
    #endif
)
{
    oPosition = mul(position, worldViewProj); //oPosition must be output to satisy pipeline.
    oPositionViewProj = oPosition;
    oTexCoord = texCoord;
    oTexCoord2 = float2((texCoord.x+time*0.2)/2,(texCoord.y+time*0.2)/2); // offset second texture coordinate
                                        // according to time for wind texture
    oVertColor = vertColor;
    
    float3 posWorld = mul(position, mWorld);
    float3 eyeDirO = normalize(-(eyePositionO-posWorld)) ; //eye vector in object space
    
    #ifdef PPLighting
    oLightDir = normalize(LightPos-posWorld);
    oNormal = normal;
    #endif
    
    // Using mesh-defined tangents. (Uncomment section to calculate them ourselves.)
    tangent = float3(abs(normal.y) + abs(normal.z),abs(normal.x),0);
    
    float3 binormal = cross(tangent,normal);
    float3x3 TBNMatrix = float3x3(tangent,binormal,normal); 
    oEyeDirTan = normalize(mul(eyeDirO,TBNMatrix)); // eye vector in tangent space
}
#define MAX_RAYDEPTH 5 //Number of iterations.
#define PLANE_NUM 16.0 //Number of grass slice grid planes per unit in tangent space.
#define PLANE_NUM_INV (1.0/PLANE_NUM)
#define PLANE_NUM_INV_DIV2 (PLANE_NUM_INV/2)
#define GRASS_SLICE_NUM 16 // Number of grass slices in texture grassblades.
#define GRASS_SLICE_NUM_INV (1.0/GRASS_SLICE_NUM)
#define GRASS_SLICE_NUM_INV_DIV2 (GRASS_SLICE_NUM_INV/2)
#define GRASSDEPTH GRASS_SLICE_NUM_INV //Depth set to inverse of number of grass slices so no stretching occurs.
#define TC1_TO_TC2_RATIO 8 //Ratio of texture coordinate set 1 to texture coordinate set 2, used for the animation lookup.
#define PREMULT (GRASS_SLICE_NUM_INV*PLANE_NUM) //Saves a multiply in the shader.
#define AVERAGE_COLOR float4(0.32156,0.513725,0.0941176,1.0) //Used to fill remaining opacity, can be replaced by a texture lookup.
sampler2D grassblades : register(s0);
sampler2D ground : register(s1);
sampler2D windnoise : register(s2);
void  pixelMain(
    in float4 vertColor      : COLOR,
    
    in float2 texCoord           : TEXCOORD0,
    in float2 texCoord2          : TEXCOORD1,
    in float3 eyeDirTan          : TEXCOORD2,
    in float4 positionViewProj  : TEXCOORD3,
    #ifdef PPLighting
    in float3 LightDir    : TEXCOORD4,
    in float3 Normal    : TEXCOORD5,
    #endif
    
    out float4 color    : COLOR
    ,out float depth        : DEPTH

)
{    
    
    //Initialize increments/decrements and per fragment constants
    color = float4(0.0,0.0,0.0,0.0);
    float2 plane_offset = float2(0.0,0.0);                    
    float3 rayEntry = float3(texCoord.xy,0.0);
    float zOffset = 0.0;
    bool zFlag = 1;

    //The signs of eyeDirTan determines if we increment or decrement along the tangent space axis
    //plane_correct, planemod and pre_dir_correct are used to avoid unneccessary if-conditions. 
     float2 signf = float2(sign(eyeDirTan.x),sign(eyeDirTan.y));    
     float2 plane_correct = float2((signf.x+1)*GRASS_SLICE_NUM_INV_DIV2,
                                   (signf.y+1)*GRASS_SLICE_NUM_INV_DIV2);
     float2 planemod = float2(floor(rayEntry.x*PLANE_NUM)/PLANE_NUM,
                              floor(rayEntry.y*PLANE_NUM)/PLANE_NUM);
    
    
    float2 pre_dir_correct = float2((signf.x+1)*PLANE_NUM_INV_DIV2,
                                    (signf.y+1)*PLANE_NUM_INV_DIV2);
                                    
    int hitcount;
    
    float2 orthoLookup; //Will contain texture lookup coordinates for grassblades texture.
        for(hitcount =0; hitcount < MAX_RAYDEPTH ; hitcount++) // %([MAX_RAYDEPTH]+1) speeds up compilation.
                                     // It may prove to be faster to early exit this loop
                                         // depending on the hardware used.
    {
        //Calculate positions of the intersections with the next grid planes on the u,v tangent space axis independently.
            float2 dir_correct = float2(signf.x*plane_offset.x+pre_dir_correct.x,
                                        signf.y*plane_offset.y+pre_dir_correct.y);            
        float2 distance = float2((planemod.x + dir_correct.x - rayEntry.x)/(eyeDirTan.x),
                                 (planemod.y + dir_correct.y - rayEntry.y)/(eyeDirTan.y));
                     
         float3 rayHitpointX = rayEntry + eyeDirTan *distance.x;   
          float3 rayHitpointY = rayEntry + eyeDirTan *distance.y;
        
        //Check if we hit the ground. If so, calculate the intersection and look up the ground texture and blend colors.
    
          if ((rayHitpointX.z <= -GRASSDEPTH)&& (rayHitpointY.z <= -GRASSDEPTH))     
          {
              float distanceZ = (-GRASSDEPTH)/eyeDirTan.z; // rayEntry.z is 0.0 anyway 
    
              float3 rayHitpointZ = rayEntry + eyeDirTan *distanceZ;
            float2 orthoLookupZ = float2(rayHitpointZ.x,rayHitpointZ.y);
                        
              color = (color)+((1.0-color.w) * tex2D(ground,orthoLookupZ));
              if(zFlag ==1) 
            zOffset = distanceZ; // write the distance from rayEntry to intersection
              zFlag = 0; //Early exit here if faster.        
          }  
          else
         {
             
             
    
             //check if we hit a u or v plane, calculate lookup accordingly with wind shear displacement.
            if(distance.x <= distance.y)
             {
                 float4 windX = (tex2D(windnoise,texCoord2+rayHitpointX.xy/TC1_TO_TC2_RATIO)-0.5)/2;
                
                float lookupX = -(rayHitpointX.z+(planemod.x+signf.x*plane_offset.x)*PREMULT)-plane_correct.x;
                orthoLookup=float2(rayHitpointX.y+windX.x*(GRASSDEPTH+rayHitpointX.z),lookupX); 
                
                plane_offset.x += PLANE_NUM_INV; // increment/decrement to next grid plane on u axis
                if(zFlag==1) zOffset = distance.x;
            }
            else {
                float4 windY = (tex2D(windnoise,texCoord2+rayHitpointY.xy/TC1_TO_TC2_RATIO)-0.5)/2;
             
                float lookupY = -(rayHitpointY.z+(planemod.y+signf.y*plane_offset.y)*PREMULT)-plane_correct.y;
                orthoLookup = float2(rayHitpointY.x+windY.y*(GRASSDEPTH+rayHitpointY.z) ,lookupY);
             
                plane_offset.y += PLANE_NUM_INV;  // increment/decrement to next grid plane on v axis
                if(zFlag==1) zOffset = distance.y;
    float4 biased;
         biased.xy = orthoLookup;
         biased.z = 0;
         biased.w = -100.0;
            
           color += (1.0-color.w)*tex2Dbias(grassblades,biased);//orthoLookup)
                    
              }
               
                 color += (1.0-color.w)*tex2D(grassblades,orthoLookup);
     
                 if(color.w >= 0.49)
            {zFlag = 0;}    //Early exit here if faster.
          }
    }    
    
        color += (1.0-color.w)*tex2D(ground,orthoLookup);     //Fill remaining transparency in case there is some left. Can be replaced by a texture lookup
                                            //into a fully opaque grass slice using orthoLookup.
        
        
        //color.xyz *= (vertColor.xyz);     //Modulate with per vertex lightmap,as an alternative, modulate with N*L for dynamic lighting.
    
    #ifdef PPLighting
        color.xyz *= dot(LightDir,Normal);
    #endif
     
        //zOffset is along eye direction, transform and add to vertex position to get correct z-value.
       // BlindSide NOTE: Commented this section out as it causes a bug.
     positionViewProj += mul(eyeDirTan.xzy*zOffset,worldViewProj); 
    
       //Divide by homogenous part.
      depth = positionViewProj.z / positionViewProj.w;
    
     //color.xyz = depth;
}
" />
				 <pixel shader=
"#define PPLighting

uniform float4x4 worldViewProj;
uniform float4x4 mWorld;
uniform float3 eyePositionO;
uniform float3 LightPos;
uniform float time; //Runs from 0 to 10 per second.
void vertexMain(
    float4 position    : POSITION,
    float3 normal    : NORMAL,
    
    float2 texCoord     : TEXCOORD0,
    float3 tangent : TEXCOORD1,
    float4 vertColor : COLOR, //In this implementation a per vertex lightmap is used
    out float4 oVertColor          : COLOR,
    out float2 oTexCoord          : TEXCOORD0,
    out float2 oTexCoord2          : TEXCOORD1,
    out float4 oPosition           : POSITION,
    out float3 oEyeDirTan          : TEXCOORD2,
    out float4 oPositionViewProj    : TEXCOORD3
    #ifdef PPLighting
        ,out float3 oLightDir    : TEXCOORD4,
        out float3 oNormal    : TEXCOORD5
    #endif
)
{
    oPosition = mul(position, worldViewProj); //oPosition must be output to satisy pipeline.
    oPositionViewProj = oPosition;
    oTexCoord = texCoord;
    oTexCoord2 = float2((texCoord.x+time*0.2)/2,(texCoord.y+time*0.2)/2); // offset second texture coordinate
                                        // according to time for wind texture
    oVertColor = vertColor;
    
    float3 posWorld = mul(position, mWorld);
    float3 eyeDirO = normalize(-(eyePositionO-posWorld)) ; //eye vector in object space
    
    #ifdef PPLighting
    oLightDir = normalize(LightPos-posWorld);
    oNormal = normal;
    #endif
    
    // Using mesh-defined tangents. (Uncomment section to calculate them ourselves.)
    tangent = float3(abs(normal.y) + abs(normal.z),abs(normal.x),0);
    
    float3 binormal = cross(tangent,normal);
    float3x3 TBNMatrix = float3x3(tangent,binormal,normal); 
    oEyeDirTan = normalize(mul(eyeDirO,TBNMatrix)); // eye vector in tangent space
}
#define MAX_RAYDEPTH 5 //Number of iterations.
#define PLANE_NUM 16.0 //Number of grass slice grid planes per unit in tangent space.
#define PLANE_NUM_INV (1.0/PLANE_NUM)
#define PLANE_NUM_INV_DIV2 (PLANE_NUM_INV/2)
#define GRASS_SLICE_NUM 16 // Number of grass slices in texture grassblades.
#define GRASS_SLICE_NUM_INV (1.0/GRASS_SLICE_NUM)
#define GRASS_SLICE_NUM_INV_DIV2 (GRASS_SLICE_NUM_INV/2)
#define GRASSDEPTH GRASS_SLICE_NUM_INV //Depth set to inverse of number of grass slices so no stretching occurs.
#define TC1_TO_TC2_RATIO 8 //Ratio of texture coordinate set 1 to texture coordinate set 2, used for the animation lookup.
#define PREMULT (GRASS_SLICE_NUM_INV*PLANE_NUM) //Saves a multiply in the shader.
#define AVERAGE_COLOR float4(0.32156,0.513725,0.0941176,1.0) //Used to fill remaining opacity, can be replaced by a texture lookup.
sampler2D grassblades : register(s0);
sampler2D ground : register(s1);
sampler2D windnoise : register(s2);
void  pixelMain(
    in float4 vertColor      : COLOR,
    
    in float2 texCoord           : TEXCOORD0,
    in float2 texCoord2          : TEXCOORD1,
    in float3 eyeDirTan          : TEXCOORD2,
    in float4 positionViewProj  : TEXCOORD3,
    #ifdef PPLighting
    in float3 LightDir    : TEXCOORD4,
    in float3 Normal    : TEXCOORD5,
    #endif
    
    out float4 color    : COLOR
    ,out float depth        : DEPTH

)
{    
    
    //Initialize increments/decrements and per fragment constants
    color = float4(0.0,0.0,0.0,0.0);
    float2 plane_offset = float2(0.0,0.0);                    
    float3 rayEntry = float3(texCoord.xy,0.0);
    float zOffset = 0.0;
    bool zFlag = 1;

    //The signs of eyeDirTan determines if we increment or decrement along the tangent space axis
    //plane_correct, planemod and pre_dir_correct are used to avoid unneccessary if-conditions. 
     float2 signf = float2(sign(eyeDirTan.x),sign(eyeDirTan.y));    
     float2 plane_correct = float2((signf.x+1)*GRASS_SLICE_NUM_INV_DIV2,
                                   (signf.y+1)*GRASS_SLICE_NUM_INV_DIV2);
     float2 planemod = float2(floor(rayEntry.x*PLANE_NUM)/PLANE_NUM,
                              floor(rayEntry.y*PLANE_NUM)/PLANE_NUM);
    
    
    float2 pre_dir_correct = float2((signf.x+1)*PLANE_NUM_INV_DIV2,
                                    (signf.y+1)*PLANE_NUM_INV_DIV2);
                                    
    int hitcount;
    
    float2 orthoLookup; //Will contain texture lookup coordinates for grassblades texture.
        for(hitcount =0; hitcount < MAX_RAYDEPTH ; hitcount++) // %([MAX_RAYDEPTH]+1) speeds up compilation.
                                     // It may prove to be faster to early exit this loop
                                         // depending on the hardware used.
    {
        //Calculate positions of the intersections with the next grid planes on the u,v tangent space axis independently.
            float2 dir_correct = float2(signf.x*plane_offset.x+pre_dir_correct.x,
                                        signf.y*plane_offset.y+pre_dir_correct.y);            
        float2 distance = float2((planemod.x + dir_correct.x - rayEntry.x)/(eyeDirTan.x),
                                 (planemod.y + dir_correct.y - rayEntry.y)/(eyeDirTan.y));
                     
         float3 rayHitpointX = rayEntry + eyeDirTan *distance.x;   
          float3 rayHitpointY = rayEntry + eyeDirTan *distance.y;
        
        //Check if we hit the ground. If so, calculate the intersection and look up the ground texture and blend colors.
    
          if ((rayHitpointX.z <= -GRASSDEPTH)&& (rayHitpointY.z <= -GRASSDEPTH))     
          {
              float distanceZ = (-GRASSDEPTH)/eyeDirTan.z; // rayEntry.z is 0.0 anyway 
    
              float3 rayHitpointZ = rayEntry + eyeDirTan *distanceZ;
            float2 orthoLookupZ = float2(rayHitpointZ.x,rayHitpointZ.y);
                        
              color = (color)+((1.0-color.w) * tex2D(ground,orthoLookupZ));
              if(zFlag ==1) 
            zOffset = distanceZ; // write the distance from rayEntry to intersection
              zFlag = 0; //Early exit here if faster.        
          }  
          else
         {
             
             
    
             //check if we hit a u or v plane, calculate lookup accordingly with wind shear displacement.
            if(distance.x <= distance.y)
             {
                 float4 windX = (tex2D(windnoise,texCoord2+rayHitpointX.xy/TC1_TO_TC2_RATIO)-0.5)/2;
                
                float lookupX = -(rayHitpointX.z+(planemod.x+signf.x*plane_offset.x)*PREMULT)-plane_correct.x;
                orthoLookup=float2(rayHitpointX.y+windX.x*(GRASSDEPTH+rayHitpointX.z),lookupX); 
                
                plane_offset.x += PLANE_NUM_INV; // increment/decrement to next grid plane on u axis
                if(zFlag==1) zOffset = distance.x;
            }
            else {
                float4 windY = (tex2D(windnoise,texCoord2+rayHitpointY.xy/TC1_TO_TC2_RATIO)-0.5)/2;
             
                float lookupY = -(rayHitpointY.z+(planemod.y+signf.y*plane_offset.y)*PREMULT)-plane_correct.y;
                orthoLookup = float2(rayHitpointY.x+windY.y*(GRASSDEPTH+rayHitpointY.z) ,lookupY);
             
                plane_offset.y += PLANE_NUM_INV;  // increment/decrement to next grid plane on v axis
                if(zFlag==1) zOffset = distance.y;
    float4 biased;
         biased.xy = orthoLookup;
         biased.z = 0;
         biased.w = -100.0;
            
           color += (1.0-color.w)*tex2Dbias(grassblades,biased);//orthoLookup)
                    
              }
               
                 color += (1.0-color.w)*tex2D(grassblades,orthoLookup);
     
                 if(color.w >= 0.49)
            {zFlag = 0;}    //Early exit here if faster.
          }
    }    
    
        color += (1.0-color.w)*tex2D(ground,orthoLookup);     //Fill remaining transparency in case there is some left. Can be replaced by a texture lookup
                                            //into a fully opaque grass slice using orthoLookup.
        
        
        //color.xyz *= (vertColor.xyz);     //Modulate with per vertex lightmap,as an alternative, modulate with N*L for dynamic lighting.
    
    #ifdef PPLighting
        color.xyz *= dot(LightDir,Normal);
    #endif
     
        //zOffset is along eye direction, transform and add to vertex position to get correct z-value.
       // BlindSide NOTE: Commented this section out as it causes a bug.
     positionViewProj += mul(eyeDirTan.xzy*zOffset,worldViewProj); 
    
       //Divide by homogenous part.
      depth = positionViewProj.z / positionViewProj.w;
    
     //color.xyz = depth;
}
" />
				 <constants value="vmatrix4 worldViewProj proj[0] view[0] world[0] 0



vmatrix4 mWorld world[0] 0 0 0



vvector3df eyePositionO camPos4



vvector3df LightPos 0 100 0



vfloat time + ctime 1000



" />
			 </materialType>

			 <materialType>
				 <pixelShaderType type="7" /> 
				 <vertexShaderType type="3" /> 
				 <baseMaterial type="0" /> 
				 <name cname="Selection Material" />
				 <vertex shader=
"float4x4 worldViewProj;







struct VertexShaderOutput {







    float4 Position : POSITION0;







    float2 TexCoords : TEXCOORD0;







};







struct VertexShaderInput {







    float4 Position : POSITION0;







    float2 TexCoords : TEXCOORD0;







};







VertexShaderOutput vertexMain(VertexShaderInput input) {







    VertexShaderOutput output = (VertexShaderOutput)0;







    







    float4 Position = mul(input.Position, worldViewProj);







    







    output.Position = Position;







    output.TexCoords = input.TexCoords;







    







    return output;







}" />
				 <pixel shader=
"sampler2D diffuse : register(s0);







struct VertexShaderOutput {







    float4 Position : POSITION0;







    float2 TexCoords : TEXCOORD0;







};







struct SAverage {







    float4 color;







    float average;







};







SAverage getAverageAt(float2 TexCoords) {







    SAverage av = (SAverage)0;







    av.color = tex2D(diffuse, TexCoords);







    av.average = (av.color.r + av.color.g + av.color.b) / 3.0;







    







    return av;







}







float4 pixelMain(VertexShaderOutput input) : COLOR0 {







    SAverage av = getAverageAt(input.TexCoords);







    float4 color;







    







    if (av.average < 0.2) {







        color = av.color;







    } else {







        float r = 136;







        float g = 84;







        float b = 245;







        float a = 255;







        color = (float4(r, g, b, a) / 255) + (av.color * -av.average);







    }







    







    return color;







}" />
				 <constants value="vmatrix4 worldViewProj proj[0] view[0] world[0] 0







vfloat time + ctime 1000







" />
			 </materialType>

			 <materialType>
				 <pixelShaderType type="3" /> 
				 <vertexShaderType type="0" /> 
				 <baseMaterial type="0" /> 
				 <name cname="Almost White Material" />
				 <vertex shader=
"float4x4 worldViewProj;







struct VertexShaderOutput {



    float4 Position : POSITION0;



};







struct VertexShaderInput {



    float4 Position : POSITION0;



};







VertexShaderOutput vertexMain(VertexShaderInput input) {







    VertexShaderOutput output = (VertexShaderOutput)0;







    float4 Position = mul(input.Position, worldViewProj);



    output.Position = Position;







    return output;



}



" />
				 <pixel shader=
"struct VertexShaderOutput {



    float4 Position : POSITION0;



};







float4 pixelMain(VertexShaderOutput input) : COLOR0 {



    return float4(245.0, 235.0, 235.0, 210.0) / 255.0;



}" />
				 <constants value="vmatrix4 worldViewProj proj[0] view[0] world[0] 0" />
			 </materialType>

			 <materialType>
				 <pixelShaderType type="0" /> 
				 <vertexShaderType type="0" /> 
				 <baseMaterial type="0" /> 
				 <name cname="Almost Grey Material" />
				 <vertex shader=
"float4x4 worldViewProj;







struct VertexShaderOutput {



    float4 Position : POSITION0;



};







struct VertexShaderInput {



    float4 Position : POSITION0;



};







VertexShaderOutput vertexMain(VertexShaderInput input) {







    VertexShaderOutput output = (VertexShaderOutput)0;







    float4 Position = mul(input.Position, worldViewProj);



    output.Position = Position;







    return output;



}



" />
				 <pixel shader=
"struct VertexShaderOutput {

    float4 Position : POSITION0;

};



float4 pixelMain(VertexShaderOutput input) : COLOR0 {

    return float4(175.0, 175.0, 175.0, 255.0) / 255.0;

}" />
				 <constants value="vmatrix4 worldViewProj proj[0] view[0] world[0] 0" />
			 </materialType>


		 </materialTypes>

		 <scripts>


		 </scripts>

	</config>



	<scene>

		 <object>

			 <path file="cube" />

			 <name c8name="#object:cube_main" />

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="255" g="255" b="236" a="210" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-5" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="67.318787" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="2.815832" Y="2.815832" Z="2.815832" />

			 <visible bool="1" />
			 <shadowMode mode="2" />
			 <actions>
			 </actions>

		 </object>

		 <object>

			 <path file="hillPlaneMesh" />

			 <name c8name="#object:plane" />

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="height_maps/grass/s_grassblades.tga" />
						 <texture id="1" path="height_maps/grass/s_grass_ground.tga" />
						 <texture id="2" path="height_maps/grass/windnoise.tga" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="255" g="255" b="235" a="210" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-2" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="0.000000" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="1.515007" Y="1.515007" Z="1.515007" />

			 <visible bool="1" />
			 <shadowMode mode="0" />
			 <actions>
			 </actions>

		 </object>

		 <object>

			 <path file="cube" />

			 <name c8name="#object:cube_support" />

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="1" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="0" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="-2.701931" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="2.825005" Y="0.120260" Z="2.825005" />

			 <visible bool="1" />
			 <shadowMode mode="2" />
			 <actions>
			 </actions>

		 </object>

		 <light>

			 <name c8name="#light:1" />

			 <position X="308.367584" Y="455.908234" Z="343.485138" />
			 <target X="0.000000" Y="0.000000" Z="0.000000" />

			 <diffuseColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />
			 <ambiantColor r="0.000000" g="0.000000" b="0.000000" a="1.000000" />
			 <specularColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />

			 <radius value="100.000000" />
			 <farValue value="1150.000000" />
			 <autoRecalculate value="0" />

			 <shadows resol="4096" />

			 <lensFlare>
				 <mesh> 
					 <scale X="0.000000" Y="0.000000" Z="0.000000" />
					 <texture path="" />
				 </mesh> 
				 <bill> 
					 <size Width="150.000000" Height="150.000000" />
					 <texture path="shaders/textures/lf/sun.png" />
				 </bill> 
				 <lfsn> 
					 <strength value="0.000000" />
					 <texture path="" />
					 <falseOcclusion value="0" />
				 </lfsn> 
				 <position X="0.000000" Y="0.000000" Z="0.000000" />
 			 </lensFlare>

		 </light>


	</scene>

</rootScene>
>>>>>>> 98982be63c0eb4af676bb57f976eb999ecfc21e8
