<?xml version="1.0"?>

<rootScene>

	<config>

		 <numberOfObjects value="4" />

		 <grid>

			 <accentLineOffset ALO="8" />
			 <size S="1024" />
			 <spacing SP="8" />

		 </grid>

		 <camera>

			 <position X="220.226959" Y="100.056831" Z="133.181030" />
			 <rotation X="358.480255" Y="238.750031" Z="0.000000" />

		 </camera>

		 <fpsCameraSettings>

			 <ellipsoidRadius X="15.000000" Y="20.000000" Z="15.000000" />
			 <gravityPerSecond X="0.000000" Y="-10.000000" Z="0.000000" />
			 <ellipsoidTranslation X="0.000000" Y="0.000000" Z="0.000000" />
			 <slidingValue value="0.000500" />

		 </fpsCameraSettings>

		 <depthPassEnabled enabled="0" />
		 <lightScaterringPassEnabled enabled="1" />
		 <reflectionPassEnabled enabled="0" />

		 <effect>

			 <postProcessingEffect>
				 <ppeName name="/sepia_toon_shader.hlsl" />
				 <ppeShader shader="//------------------------------ TEXTURE PROPERTIES ----------------------------
// This is the texture that SpriteBatch will try to set before drawing
texture ScreenTexture;
 
// Our sampler for the texture, which is just going to be pretty simple
sampler TextureSampler = sampler_state
{
    Texture = <ScreenTexture>;
};
 
//------------------------ PIXEL SHADER ----------------------------------------
// This pixel shader will simply look up the color of the texture at the
// requested point, and turns it into a sepia tone
float4 pixelMain(float2 TextureCoordinate : TEXCOORD0) : COLOR0
{
    float4 color = tex2D(TextureSampler, TextureCoordinate);
 
    float4 outputColor = color;
    outputColor.r = (color.r * 0.393) + (color.g * 0.769) + (color.b * 0.189);
    outputColor.g = (color.r * 0.349) + (color.g * 0.686) + (color.b * 0.168);    
    outputColor.b = (color.r * 0.272) + (color.g * 0.534) + (color.b * 0.131);
 
    return outputColor;
}
 
//-------------------------- TECHNIQUES ----------------------------------------
// This technique is pretty simple - only one pass, and only a pixel shader
technique Sepia
{
    pass Pass1
    {
        PixelShader = compile ps_2_0 pixelMain();
    }
}
" />
				 <ppeCallback callback="" />
			 </postProcessingEffect>

			 <postProcessingEffect>
				 <ppeName name="/godrays.hlsl" />
				 <ppeShader shader="
sampler2D ColorMapSampler : register(s0);
sampler2D UserMapSampler : register(s3);

float2 lightPositionOnScreen;
		
//float decay=0.96815;
//float exposure=0.2;
//float density=0.26;
//float weight=0.58767;

float4 pixelMain(float2 texCoord : TEXCOORD0) : COLOR0
{
	float decay=0.97815;
	float exposure=0.92;
	float density=0.966;
	float weight=0.58767;

	int NUM_SAMPLES = 100;
	
	float2 tc = texCoord;
 	float2 deltaTexCoord = (tc - lightPositionOnScreen.xy);  
 	deltaTexCoord *= 1.0f / NUM_SAMPLES * density;  
 	
 	float illuminationDecay = 1.0;

	float4 color =tex2D(UserMapSampler, tc)*0.4;
	
 	for(int i=0; i < NUM_SAMPLES ; i++)
  	{
		tc -= deltaTexCoord;
		float4 sample = tex2D(UserMapSampler, tc)*0.4;
		sample *= illuminationDecay * weight;  
		color += sample;
		illuminationDecay *= decay;  
 	}

 	//gl_FragColor *= exposure;
 	//gl_FragColor += texture2D(ColorMapSampler, textCoo.xy);
 	float4 realColor = tex2D(ColorMapSampler, texCoord.xy);
 	//gl_FragColor = ((vec4((vec3(color.r,color.g,color.b) * exposure),1))+(realColor*(1.5-0.4)));
	//gl_FragColor = color;
	//return ((float4((float3(color.r,color.g,color.b) * exposure),1))+(realColor*(1.5-0.4)));
	//return realColor + float3(color.r, color.g, color.b) * exposure));
	//return color + realColor;
	//return float4( float3(color.r, color.g, color.b) * exposure, 1) + realColor;
	//return float4( color * exposure, 1);
	//return realColor + float4(color.r, color.g, color.b, 1);

	return ((float4((float3(color.r,color.g,color.b) * exposure),1))+(realColor*(1.5-0.4)));
}

" />
				 <ppeCallback callback="driver:setRttTexture(&quotLightScatteringRTT&quot)

position = utils:getScreenCoordinatesFrom3DPosition(driver:getLightPosition(0))
position.y = 1-position.y

filter:setPixelShaderConstantVector2D(&quotlightPositionOnScreen&quot, position)

" />
			 </postProcessingEffect>

			 <postProcessingEffect>
				 <ppeName name="/blurhp.hlsl" />
				 <ppeShader shader="sampler2D ColorMapSampler : register(s0);

float4 pixelMain ( float4 Texcoords : TEXCOORD0 ) : COLOR0
{
	const float2 offsetArray[4] = 
	{
		float2(1.0 / SCREENX, 0),
		float2(-1.0 / SCREENX, 0),
		float2(2.0 / SCREENX, 0),
		float2(-2.0 / SCREENX, 0)
	};

	float4 finalVal = float4(0.0, 0.0, 0.0, 0.0);

	for(int i = 0;i < 4;++i)
		finalVal += tex2D(ColorMapSampler, clamp(Texcoords.xy + offsetArray[i] * 2.25, float2(0.0, 0.0), float2(1.0, 1.0)));

	finalVal /= 4.0f;
	return finalVal;
}
" />
				 <ppeCallback callback="" />
			 </postProcessingEffect>

			 <postProcessingEffect>
				 <ppeName name="/blurvp.hlsl" />
				 <ppeShader shader="sampler2D ColorMapSampler : register(s0);

float4 pixelMain ( float4 Texcoords : TEXCOORD0 ) : COLOR0
{
	const float2 offsetArray[4] = 
	{
		float2(0, 1.0 / SCREENY),
		float2(0, -1.0 / SCREENY),
		float2(0, 2.0 / SCREENY),
		float2(0, -2.0 / SCREENY)
	};

	float4 finalVal = float4(0.0, 0.0, 0.0, 0.0);

	for(int i = 0;i < 4;++i)
		finalVal += tex2D(ColorMapSampler, clamp(Texcoords.xy + offsetArray[i] * 2.25, float2(0.0, 0.01), float2(1.0, 1.0)));

	finalVal /= 4.0f;
	return finalVal;
}
" />
				 <ppeCallback callback="" />
			 </postProcessingEffect>

			 <postProcessingEffect>
				 <ppeName name="/bloomp.hlsl" />
				 <ppeShader shader="sampler2D ColorMapSampler : register(s0);
sampler2D ScreenMapSampler : register(s1);

float4 pixelMain(float2 TexCoords : TEXCOORD0) : COLOR0
{		
	float4 screenCol = tex2D(ScreenMapSampler, TexCoords);
	float4 bloomCol = tex2D(ColorMapSampler, TexCoords);
	
	return(screenCol * 0.9 + bloomCol * 0.5);
}
" />
				 <ppeCallback callback="" />
			 </postProcessingEffect>


		 </effect>

		 <materialTypes>

			 <materialType>
				 <pixelShaderType type="7" /> 
				 <vertexShaderType type="3" /> 
				 <baseMaterial type="0" /> 
				 <name cname="grass_shader.spkg" />
				 <vertex shader=
"uniform float4x4 worldViewProj;

uniform float4x4 mWorld;

uniform float3 eyePositionO;

uniform float3 LightPos;

uniform float time; //Runs from 0 to 10 per second.



#define PPLighting



void vertexMain(



    float4 position    : POSITION,

    float3 normal    : NORMAL,

    

    float2 texCoord     : TEXCOORD0,

    float3 tangent : TEXCOORD1,



    float4 vertColor : COLOR, //In this implementation a per vertex lightmap is used



    out float4 oVertColor          : COLOR,

    out float2 oTexCoord          : TEXCOORD0,

    out float2 oTexCoord2          : TEXCOORD1,

    out float4 oPosition           : POSITION,

    out float3 oEyeDirTan          : TEXCOORD2,

    out float4 oPositionViewProj    : TEXCOORD3

    #ifdef PPLighting

        ,out float3 oLightDir    : TEXCOORD4,

        out float3 oNormal    : TEXCOORD5

    #endif

)

{

    oPosition = mul(position, worldViewProj); //oPosition must be output to satisy pipeline.

    oPositionViewProj = oPosition;



    oTexCoord = texCoord;

    oTexCoord2 = float2((texCoord.x+time*0.2)/2,(texCoord.y+time*0.2)/2); // offset second texture coordinate

                                        // according to time for wind texture



    oVertColor = vertColor;

    

    float3 posWorld = mul(position, mWorld);

    float3 eyeDirO = normalize(-(eyePositionO-posWorld)) ; //eye vector in object space

    

    #ifdef PPLighting

    oLightDir = normalize(LightPos-posWorld);

    oNormal = normal;

    #endif

    

    // Using mesh-defined tangents. (Uncomment section to calculate them ourselves.)

    tangent = float3(abs(normal.y) + abs(normal.z),abs(normal.x),0);

    

    float3 binormal = cross(tangent,normal);

    float3x3 TBNMatrix = float3x3(tangent,binormal,normal); 



    oEyeDirTan = normalize(mul(eyeDirO,TBNMatrix)); // eye vector in tangent space

}



#define MAX_RAYDEPTH 5 //Number of iterations.



#define PLANE_NUM 16.0 //Number of grass slice grid planes per unit in tangent space.



#define PLANE_NUM_INV (1.0/PLANE_NUM)

#define PLANE_NUM_INV_DIV2 (PLANE_NUM_INV/2)



#define GRASS_SLICE_NUM 16 // Number of grass slices in texture grassblades.



#define GRASS_SLICE_NUM_INV (1.0/GRASS_SLICE_NUM)

#define GRASS_SLICE_NUM_INV_DIV2 (GRASS_SLICE_NUM_INV/2)



#define GRASSDEPTH GRASS_SLICE_NUM_INV //Depth set to inverse of number of grass slices so no stretching occurs.



#define TC1_TO_TC2_RATIO 8 //Ratio of texture coordinate set 1 to texture coordinate set 2, used for the animation lookup.



#define PREMULT (GRASS_SLICE_NUM_INV*PLANE_NUM) //Saves a multiply in the shader.



#define AVERAGE_COLOR float4(0.32156,0.513725,0.0941176,1.0) //Used to fill remaining opacity, can be replaced by a texture lookup.



sampler2D grassblades : register(s0);

sampler2D ground : register(s1);

sampler2D windnoise : register(s2);



void  pixelMain(



    in float4 vertColor      : COLOR,

    

    in float2 texCoord           : TEXCOORD0,

    in float2 texCoord2          : TEXCOORD1,

    in float3 eyeDirTan          : TEXCOORD2,

    in float4 positionViewProj  : TEXCOORD3,

    #ifdef PPLighting

    in float3 LightDir    : TEXCOORD4,

    in float3 Normal    : TEXCOORD5,

    #endif

    

    out float4 color    : COLOR

    ,out float depth        : DEPTH)

{    

    

    //Initialize increments/decrements and per fragment constants

    color = float4(0.0,0.0,0.0,0.0);



    float2 plane_offset = float2(0.0,0.0);                    

    float3 rayEntry = float3(texCoord.xy,0.0);

    float zOffset = 0.0;

    bool zFlag = 1;    //The signs of eyeDirTan determines if we increment or decrement along the tangent space axis

    //plane_correct, planemod and pre_dir_correct are used to avoid unneccessary if-conditions. 



     float2 signf = float2(sign(eyeDirTan.x),sign(eyeDirTan.y));    

     float2 plane_correct = float2((signf.x+1)*GRASS_SLICE_NUM_INV_DIV2,

                                   (signf.y+1)*GRASS_SLICE_NUM_INV_DIV2);

     float2 planemod = float2(floor(rayEntry.x*PLANE_NUM)/PLANE_NUM,

                              floor(rayEntry.y*PLANE_NUM)/PLANE_NUM);

    

    



    float2 pre_dir_correct = float2((signf.x+1)*PLANE_NUM_INV_DIV2,

                                    (signf.y+1)*PLANE_NUM_INV_DIV2);

                                    

    int hitcount;

    

    float2 orthoLookup; //Will contain texture lookup coordinates for grassblades texture.

        for(hitcount =0; hitcount < MAX_RAYDEPTH ; hitcount++) // %([MAX_RAYDEPTH]+1) speeds up compilation.

                                     // It may prove to be faster to early exit this loop

                                         // depending on the hardware used.

    {



        //Calculate positions of the intersections with the next grid planes on the u,v tangent space axis independently.



            float2 dir_correct = float2(signf.x*plane_offset.x+pre_dir_correct.x,

                                        signf.y*plane_offset.y+pre_dir_correct.y);            

        float2 distance = float2((planemod.x + dir_correct.x - rayEntry.x)/(eyeDirTan.x),

                                 (planemod.y + dir_correct.y - rayEntry.y)/(eyeDirTan.y));

                     

         float3 rayHitpointX = rayEntry + eyeDirTan *distance.x;   

          float3 rayHitpointY = rayEntry + eyeDirTan *distance.y;

        

        //Check if we hit the ground. If so, calculate the intersection and look up the ground texture and blend colors.

    

          if ((rayHitpointX.z <= -GRASSDEPTH)&& (rayHitpointY.z <= -GRASSDEPTH))     

          {

              float distanceZ = (-GRASSDEPTH)/eyeDirTan.z; // rayEntry.z is 0.0 anyway 

    

              float3 rayHitpointZ = rayEntry + eyeDirTan *distanceZ;

            float2 orthoLookupZ = float2(rayHitpointZ.x,rayHitpointZ.y);

                        

              color = (color)+((1.0-color.w) * tex2D(ground,orthoLookupZ));

              if(zFlag ==1) 

            zOffset = distanceZ; // write the distance from rayEntry to intersection

              zFlag = 0; //Early exit here if faster.        

          }  

          else

         {

             

             

    

             //check if we hit a u or v plane, calculate lookup accordingly with wind shear displacement.

            if(distance.x <= distance.y)

             {

                 float4 windX = (tex2D(windnoise,texCoord2+rayHitpointX.xy/TC1_TO_TC2_RATIO)-0.5)/2;

                

                float lookupX = -(rayHitpointX.z+(planemod.x+signf.x*plane_offset.x)*PREMULT)-plane_correct.x;

                orthoLookup=float2(rayHitpointX.y+windX.x*(GRASSDEPTH+rayHitpointX.z),lookupX); 

                

                plane_offset.x += PLANE_NUM_INV; // increment/decrement to next grid plane on u axis

                if(zFlag==1) zOffset = distance.x;

            }

            else {

                float4 windY = (tex2D(windnoise,texCoord2+rayHitpointY.xy/TC1_TO_TC2_RATIO)-0.5)/2;

             

                float lookupY = -(rayHitpointY.z+(planemod.y+signf.y*plane_offset.y)*PREMULT)-plane_correct.y;

                orthoLookup = float2(rayHitpointY.x+windY.y*(GRASSDEPTH+rayHitpointY.z) ,lookupY);

             

                plane_offset.y += PLANE_NUM_INV;  // increment/decrement to next grid plane on v axis

                if(zFlag==1) zOffset = distance.y;



    float4 biased;

         biased.xy = orthoLookup;

         biased.z = 0;

         biased.w = -100.0;

            

           color += (1.0-color.w)*tex2Dbias(grassblades,biased);//orthoLookup)

                    

              }

               

                 color += (1.0-color.w)*tex2D(grassblades,orthoLookup);

     

                 if(color.w >= 0.49)

            {zFlag = 0;}    //Early exit here if faster.

          }

    }    

    

        color += (1.0-color.w)*tex2D(ground,orthoLookup);     //Fill remaining transparency in case there is some left. Can be replaced by a texture lookup

                                            //into a fully opaque grass slice using orthoLookup.

        

        

        //color.xyz *= (vertColor.xyz);     //Modulate with per vertex lightmap,as an alternative, modulate with N*L for dynamic lighting.

    

    #ifdef PPLighting

        color.xyz *= dot(LightDir,Normal);

    #endif

     

        //zOffset is along eye direction, transform and add to vertex position to get correct z-value.

       // BlindSide NOTE: Commented this section out as it causes a bug.

     positionViewProj += mul(eyeDirTan.xzy*zOffset,worldViewProj); 

    

       //Divide by homogenous part.

      depth = positionViewProj.z / positionViewProj.w;

    

     //color.xyz = depth;

}

" />
				 <pixel shader=
"uniform float4x4 worldViewProj;

uniform float4x4 mWorld;

uniform float3 eyePositionO;

uniform float3 LightPos;

uniform float time; //Runs from 0 to 10 per second.



#define PPLighting



void vertexMain(



    float4 position    : POSITION,

    float3 normal    : NORMAL,

    

    float2 texCoord     : TEXCOORD0,

    float3 tangent : TEXCOORD1,



    float4 vertColor : COLOR, //In this implementation a per vertex lightmap is used



    out float4 oVertColor          : COLOR,

    out float2 oTexCoord          : TEXCOORD0,

    out float2 oTexCoord2          : TEXCOORD1,

    out float4 oPosition           : POSITION,

    out float3 oEyeDirTan          : TEXCOORD2,

    out float4 oPositionViewProj    : TEXCOORD3

    #ifdef PPLighting

        ,out float3 oLightDir    : TEXCOORD4,

        out float3 oNormal    : TEXCOORD5

    #endif

)

{

    oPosition = mul(position, worldViewProj); //oPosition must be output to satisy pipeline.

    oPositionViewProj = oPosition;



    oTexCoord = texCoord;

    oTexCoord2 = float2((texCoord.x+time*0.2)/2,(texCoord.y+time*0.2)/2); // offset second texture coordinate

                                        // according to time for wind texture



    oVertColor = vertColor;

    

    float3 posWorld = mul(position, mWorld);

    float3 eyeDirO = normalize(-(eyePositionO-posWorld)) ; //eye vector in object space

    

    #ifdef PPLighting

    oLightDir = normalize(LightPos-posWorld);

    oNormal = normal;

    #endif

    

    // Using mesh-defined tangents. (Uncomment section to calculate them ourselves.)

    tangent = float3(abs(normal.y) + abs(normal.z),abs(normal.x),0);

    

    float3 binormal = cross(tangent,normal);

    float3x3 TBNMatrix = float3x3(tangent,binormal,normal); 



    oEyeDirTan = normalize(mul(eyeDirO,TBNMatrix)); // eye vector in tangent space

}



#define MAX_RAYDEPTH 5 //Number of iterations.



#define PLANE_NUM 16.0 //Number of grass slice grid planes per unit in tangent space.



#define PLANE_NUM_INV (1.0/PLANE_NUM)

#define PLANE_NUM_INV_DIV2 (PLANE_NUM_INV/2)



#define GRASS_SLICE_NUM 16 // Number of grass slices in texture grassblades.



#define GRASS_SLICE_NUM_INV (1.0/GRASS_SLICE_NUM)

#define GRASS_SLICE_NUM_INV_DIV2 (GRASS_SLICE_NUM_INV/2)



#define GRASSDEPTH GRASS_SLICE_NUM_INV //Depth set to inverse of number of grass slices so no stretching occurs.



#define TC1_TO_TC2_RATIO 8 //Ratio of texture coordinate set 1 to texture coordinate set 2, used for the animation lookup.



#define PREMULT (GRASS_SLICE_NUM_INV*PLANE_NUM) //Saves a multiply in the shader.



#define AVERAGE_COLOR float4(0.32156,0.513725,0.0941176,1.0) //Used to fill remaining opacity, can be replaced by a texture lookup.



sampler2D grassblades : register(s0);

sampler2D ground : register(s1);

sampler2D windnoise : register(s2);



void  pixelMain(



    in float4 vertColor      : COLOR,

    

    in float2 texCoord           : TEXCOORD0,

    in float2 texCoord2          : TEXCOORD1,

    in float3 eyeDirTan          : TEXCOORD2,

    in float4 positionViewProj  : TEXCOORD3,

    #ifdef PPLighting

    in float3 LightDir    : TEXCOORD4,

    in float3 Normal    : TEXCOORD5,

    #endif

    

    out float4 color    : COLOR

    ,out float depth        : DEPTH)

{    

    

    //Initialize increments/decrements and per fragment constants

    color = float4(0.0,0.0,0.0,0.0);



    float2 plane_offset = float2(0.0,0.0);                    

    float3 rayEntry = float3(texCoord.xy,0.0);

    float zOffset = 0.0;

    bool zFlag = 1;    //The signs of eyeDirTan determines if we increment or decrement along the tangent space axis

    //plane_correct, planemod and pre_dir_correct are used to avoid unneccessary if-conditions. 



     float2 signf = float2(sign(eyeDirTan.x),sign(eyeDirTan.y));    

     float2 plane_correct = float2((signf.x+1)*GRASS_SLICE_NUM_INV_DIV2,

                                   (signf.y+1)*GRASS_SLICE_NUM_INV_DIV2);

     float2 planemod = float2(floor(rayEntry.x*PLANE_NUM)/PLANE_NUM,

                              floor(rayEntry.y*PLANE_NUM)/PLANE_NUM);

    

    



    float2 pre_dir_correct = float2((signf.x+1)*PLANE_NUM_INV_DIV2,

                                    (signf.y+1)*PLANE_NUM_INV_DIV2);

                                    

    int hitcount;

    

    float2 orthoLookup; //Will contain texture lookup coordinates for grassblades texture.

        for(hitcount =0; hitcount < MAX_RAYDEPTH ; hitcount++) // %([MAX_RAYDEPTH]+1) speeds up compilation.

                                     // It may prove to be faster to early exit this loop

                                         // depending on the hardware used.

    {



        //Calculate positions of the intersections with the next grid planes on the u,v tangent space axis independently.



            float2 dir_correct = float2(signf.x*plane_offset.x+pre_dir_correct.x,

                                        signf.y*plane_offset.y+pre_dir_correct.y);            

        float2 distance = float2((planemod.x + dir_correct.x - rayEntry.x)/(eyeDirTan.x),

                                 (planemod.y + dir_correct.y - rayEntry.y)/(eyeDirTan.y));

                     

         float3 rayHitpointX = rayEntry + eyeDirTan *distance.x;   

          float3 rayHitpointY = rayEntry + eyeDirTan *distance.y;

        

        //Check if we hit the ground. If so, calculate the intersection and look up the ground texture and blend colors.

    

          if ((rayHitpointX.z <= -GRASSDEPTH)&& (rayHitpointY.z <= -GRASSDEPTH))     

          {

              float distanceZ = (-GRASSDEPTH)/eyeDirTan.z; // rayEntry.z is 0.0 anyway 

    

              float3 rayHitpointZ = rayEntry + eyeDirTan *distanceZ;

            float2 orthoLookupZ = float2(rayHitpointZ.x,rayHitpointZ.y);

                        

              color = (color)+((1.0-color.w) * tex2D(ground,orthoLookupZ));

              if(zFlag ==1) 

            zOffset = distanceZ; // write the distance from rayEntry to intersection

              zFlag = 0; //Early exit here if faster.        

          }  

          else

         {

             

             

    

             //check if we hit a u or v plane, calculate lookup accordingly with wind shear displacement.

            if(distance.x <= distance.y)

             {

                 float4 windX = (tex2D(windnoise,texCoord2+rayHitpointX.xy/TC1_TO_TC2_RATIO)-0.5)/2;

                

                float lookupX = -(rayHitpointX.z+(planemod.x+signf.x*plane_offset.x)*PREMULT)-plane_correct.x;

                orthoLookup=float2(rayHitpointX.y+windX.x*(GRASSDEPTH+rayHitpointX.z),lookupX); 

                

                plane_offset.x += PLANE_NUM_INV; // increment/decrement to next grid plane on u axis

                if(zFlag==1) zOffset = distance.x;

            }

            else {

                float4 windY = (tex2D(windnoise,texCoord2+rayHitpointY.xy/TC1_TO_TC2_RATIO)-0.5)/2;

             

                float lookupY = -(rayHitpointY.z+(planemod.y+signf.y*plane_offset.y)*PREMULT)-plane_correct.y;

                orthoLookup = float2(rayHitpointY.x+windY.y*(GRASSDEPTH+rayHitpointY.z) ,lookupY);

             

                plane_offset.y += PLANE_NUM_INV;  // increment/decrement to next grid plane on v axis

                if(zFlag==1) zOffset = distance.y;



    float4 biased;

         biased.xy = orthoLookup;

         biased.z = 0;

         biased.w = -100.0;

            

           color += (1.0-color.w)*tex2Dbias(grassblades,biased);//orthoLookup)

                    

              }

               

                 color += (1.0-color.w)*tex2D(grassblades,orthoLookup);

     

                 if(color.w >= 0.49)

            {zFlag = 0;}    //Early exit here if faster.

          }

    }    

    

        color += (1.0-color.w)*tex2D(ground,orthoLookup);     //Fill remaining transparency in case there is some left. Can be replaced by a texture lookup

                                            //into a fully opaque grass slice using orthoLookup.

        

        

        //color.xyz *= (vertColor.xyz);     //Modulate with per vertex lightmap,as an alternative, modulate with N*L for dynamic lighting.

    

    #ifdef PPLighting

        color.xyz *= dot(LightDir,Normal);

    #endif

     

        //zOffset is along eye direction, transform and add to vertex position to get correct z-value.

       // BlindSide NOTE: Commented this section out as it causes a bug.

     positionViewProj += mul(eyeDirTan.xzy*zOffset,worldViewProj); 

    

       //Divide by homogenous part.

      depth = positionViewProj.z / positionViewProj.w;

    

     //color.xyz = depth;

}

" />
				 <constants value="vmatrix4 worldViewProj proj[0] view[0] world[0] 0

vmatrix4 mWorld world[0] 0 0 0

vvector3df eyePositionO camPos4

vvector3df LightPos 308 455 343

vfloat time + ctime 1000

" />
			 </materialType>


		 </materialTypes>

		 <scripts>


		 </scripts>

		 <physics>
			 <gravity X="0.000000" Y="-50.000000" Z="0.000000" />
		 </physics>

	</config>



	<scene>

		 <object>

			 <path file="hillPlaneMesh" />

			 <name c8name="#object:new_hille_plane_mesh" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="1" />
				 <planarMappedValue value="0.020000" />
				 </planarMapping>

			 </factory> 

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="height_maps/grass/s_grassblades.tga" />
						 <texture id="1" path="height_maps/grass/s_grass_ground.tga" />
						 <texture id="2" path="height_maps/grass/windnoise.tga" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="-1" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="0.000000" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="1.000000" Y="1.000000" Z="1.000000" />

			<depthPassed value="0" />
			<lightScatteringPassed value="0" />

			 <visible bool="1" />
			 <shadowMode mode="0" />
			 <actions>
			 </actions>

			 <physics>
			 	 <body type="0">
			 	 </body>
			 </physics>

		 </object>

		 <object>

			 <path file="cube" />

			 <name c8name="#object:new_cube" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="0" />
				 <planarMappedValue value="0.000000" />
				 </planarMapping>

			 </factory> 

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="255" g="255" b="255" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="255" g="255" b="255" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="0" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="0" />

			 	 </material>
			 </materials>
			 <position X="0.000000" Y="80.086220" Z="0.000000" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="3.300000" Y="3.300000" Z="3.300000" />

			<depthPassed value="1" />
			<lightScatteringPassed value="1" />

			 <visible bool="1" />
			 <shadowMode mode="2" />
			 <actions>
			 </actions>

			 <physics>
			 	 <body type="0">
			 	 </body>
			 </physics>

		 </object>

		 <object>

			 <path file="data/architecture/garden/mp5/idle.x" />

			 <name c8name="#object:mp5" />

			 <factory> 

				 <meshFactory>
				 <tangents value="0" />
				 <normals value="0" />
				 <angleWeighted value="0" />
				 <smooth value="0" />
				 </meshFactory>
				 <planarMapping>
				 <planarMapped value="0" />
				 <planarMappedValue value="0.000000" />
				 </planarMapping>

			 </factory> 

			 <materials>
			 	 <material id="0">
					 <textures>
						 <texture id="0" path="data/architecture/garden/mp5/idle.fbm/mp5_d.jpg" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="150" g="150" b="150" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="128" g="128" b="128" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="255" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="59.772800" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="0" />

			 	 </material>
			 	 <material id="1">
					 <textures>
						 <texture id="0" path="data/architecture/garden/mp5/idle.fbm/aimpoint_sight.jpg" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="150" g="150" b="150" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="0" g="0" b="0" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="255" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="12" />

			 	 </material>
			 	 <material id="2">
					 <textures>
						 <texture id="0" path="data/architecture/garden/mp5/idle.fbm/hands_1stp_military_diff.jpg" />
						 <texture id="1" path="" />
						 <texture id="2" path="" />
						 <texture id="3" path="" />
					 <textures>

					 <diffuseColor r="150" g="150" b="150" a="255" />
					 <ambiantColor r="255" g="255" b="255" a="255" />
					 <specularColor r="0" g="0" b="0" a="255" />
					 <emissiveColor r="0" g="0" b="0" a="255" />

					 <lighting value="0" />

					 <materialTypeParam1 value="0.000000" />
					 <materialTypeParam2 value="0.000000" />

					 <shininess value="0.000000" />
					 <thickness value="1.000000" />

					 <antiAliasing value="1" />
					 <backfaceCulling value="1" />
					 <colorMask value="15" />
					 <colorMaterial value="1" />
					 <fogEnable value="0" />
					 <frontfaceCulling value="0" />
					 <gouraudShading value="1" />
					 <normalizeNormals value="0" />
					 <zBuffer value="1" />
					 <zWriteEnable value="1" />

					 <materianType value="0" />

			 	 </material>
			 </materials>
			 <position X="182.357285" Y="41.077732" Z="78.667984" />
			 <rotation X="0.000000" Y="0.000000" Z="0.000000" />
			 <scale X="1.000000" Y="1.000000" Z="1.000000" />

			<depthPassed value="0" />
			<lightScatteringPassed value="1" />

			 <visible bool="1" />
			 <shadowMode mode="2" />
			 <actions>
				 <action start="0" end="9440" name="IDLE" speed="4000.000000" animPath="" /> 

				 <action start="0" end="18080" name="RELOAD" speed="4000.000000" animPath="data/architecture/garden/mp5/reload.x" /> 

				 <action start="0" end="9440" name="FIRE" speed="4000.000000" animPath="data/architecture/garden/mp5/fire.x" /> 

			 </actions>

			 <physics>
			 	 <body type="0">
			 	 </body>
			 </physics>

		 </object>

		 <light>

			 <name c8name="#light:new_light" />

			 <position X="-64.776123" Y="261.182617" Z="-25.786285" />
			 <target X="0.000000" Y="0.000000" Z="0.000000" />

			 <diffuseColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />
			 <ambiantColor r="0.000000" g="0.000000" b="0.000000" a="1.000000" />
			 <specularColor r="1.000000" g="1.000000" b="1.000000" a="1.000000" />

			 <radius value="100.000000" />
			 <farValue value="1000.000000" />
			 <autoRecalculate value="1" />

			 <shadows resol="1024" />

			 <lensFlare>
				 <mesh> 
					 <scale X="0.000000" Y="0.000000" Z="0.000000" />
					 <texture path="" />
				 </mesh> 
				 <bill> 
					 <size Width="109.000000" Height="109.000000" />
					 <texture path="shaders/textures/lf/sun.png" />
				 </bill> 
				 <lfsn> 
					 <strength value="0.000000" />
					 <texture path="" />
					 <falseOcclusion value="0" />
				 </lfsn> 
				 <position X="0.000000" Y="0.000000" Z="0.000000" />
 			 </lensFlare>

		 </light>


	</scene>

</rootScene>
