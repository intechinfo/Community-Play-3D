#define __CP3D_MAX_LIGHTS__ 8

float4x4 matWorldInverse; 
float4x4 ModelViewMatrix;
float3 fvLightPosition[__CP3D_MAX_LIGHTS__];
float fLightStrength[__CP3D_MAX_LIGHTS__]; 
float4 fvAmbient;
float4 fvLightColor[__CP3D_MAX_LIGHTS__];
float fSpecularPower; 
float fSpecularStrength; 
float fBumpStrength; 
int numLights;

sampler2D baseMap      : register(s0); 
sampler2D bumpMap      : register(s1); 

struct PS_INPUT
{   
   float2 Texcoord            : TEXCOORD0;
   float3 Normal			  : TEXCOORD1;
   float4 ObjectPosition	  : TEXCOORD2;
};

float getLengthSQR (float3 vec) 
{ 
   return(vec.x*vec.x+vec.y*vec.y+vec.z*vec.z); 
}

float4 pixelMain( in PS_INPUT IN ) : COLOR
{
	/// Added vertex
	float4x4 LightTransform= ModelViewMatrix; 
	LightTransform= mul(matWorldInverse, LightTransform);
	float4 fvObjectPosition = IN.ObjectPosition;

	float3 fvTangent   = -float3(abs(IN.Normal.y) + abs(IN.Normal.z), abs(IN.Normal.x), 0); 
	float3 fvBinormal   = cross(fvTangent,IN.Normal);
	float3 fvNormal     = mul(IN.Normal, ModelViewMatrix); 
	fvTangent         = mul( cross(fvBinormal, IN.Normal), ModelViewMatrix ); 
	fvBinormal         = mul( fvBinormal, ModelViewMatrix ); 

	float3 fvViewDirection  =  - fvObjectPosition.xyz; 
	float3 ViewDirection = float3(0.0, 0.0, 0.0);
	ViewDirection.x  = dot( fvTangent, fvViewDirection ); 
	ViewDirection.y  = dot( fvBinormal, fvViewDirection ); 
	ViewDirection.z  = dot( fvNormal, fvViewDirection ); 

	/// End added vertex

	float4 color = float4(0,0,0,0);
	float3  fvNormal2         = tex2D( bumpMap, IN.Texcoord ).yxz; 
   
	fvNormal2.xy*=2.0; 
	fvNormal2.xy-=1.0;
	fvNormal2=(float3(0.0,0.0,1.0)-fvNormal2)*fBumpStrength+fvNormal2; 
	fvNormal2=normalize(fvNormal2);
   
	float4  fvBaseColor      = tex2D( baseMap, IN.Texcoord );
	float4  fvTotalAmbient   = fvAmbient * fvBaseColor;
	float4  fvTotalDiffuse   = float4(0.0, 0.0, 0.0, 0.0);
	float4  fvTotalSpecular  = float4(0.0, 0.0, 0.0, 0.0);

	for (int i=0; i < numLights; i++) {
		/// Added vertex
		float4 fvLightPos1 = mul(float4(fvLightPosition[i],1.0), LightTransform);
		float3 fvLightDirection1 = (fvLightPos1.xyz - fvObjectPosition.xyz);

		float3 LightDirection1;
		LightDirection1.x  = dot( fvTangent, fvLightDirection1.xyz ); 
		LightDirection1.y  = dot( fvBinormal, fvLightDirection1.xyz ); 
		LightDirection1.z  = dot( fvNormal, fvLightDirection1.xyz );

		float3  fvLightDirection2 = normalize( LightDirection1 );

		float LightDistMultiplier=1.0/(getLengthSQR (fvLightDirection1)/(fLightStrength[i]*10000.0)); 
		/// End added pixel

		float fNDotL1            = max(dot(fvNormal2, fvLightDirection2),0.0)-0.1;  
		float3  fvReflection1    = normalize( ( ( 2.0 * fvNormal2 )  ) - fvLightDirection2 );  
		float3  fvViewDirection2  = normalize( ViewDirection ); 
		float fRDotV1            = max( 0.0, dot( fvReflection1, fvViewDirection2 ) ); 

		fvTotalDiffuse			 += fvLightColor[i] * fNDotL1* fvBaseColor*LightDistMultiplier;  
		fvTotalSpecular			 += fNDotL1*fvLightColor[i] * ( pow( fRDotV1, fSpecularPower ) )*LightDistMultiplier;
	}

	color=( fvTotalAmbient + fvTotalDiffuse+ (fvTotalSpecular*fSpecularStrength)); 
	if(color.r>1.0){color.gb+=color.r-1.0;} 
	if(color.g>1.0){color.rb+=color.g-1.0;} 
	if(color.b>1.0){color.rg+=color.b-1.0;} 
   
   return color;
}
