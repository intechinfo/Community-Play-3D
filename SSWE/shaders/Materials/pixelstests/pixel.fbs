float4 fvAmbient;
float4 fvSpecular;
float4 fvDiffuse;
float fSpecularPower;
float3 lightDirection;
 
sampler2D baseX : register(s0);
sampler2D baseY : baseX;
sampler2D baseZ : baseY;
sampler2D normalX : register(s1);
sampler2D normalY : normalX;
sampler2D normalZ : normalY;
 
struct PS_INPUT 
{
   float4 Position :        POSITION0;
   float2 TexcoordX :       TEXCOORD0;
   float2 TexcoordY :       TEXCOORD1;
   float2 TexcoordZ :       TEXCOORD2;
   float3 viewDirection   : TEXCOORD3;
   float3x3 tangentSpace :  TEXCOORD4;
};
 
float4 pixelMain( PS_INPUT Input ) : COLOR0
{      
   float3 fvLightDirection = normalize( lightDirection );
   float3 fvNormal         = normalize( Input.tangentSpace[2]);
   float3 fvViewDirection  = normalize( Input.viewDirection );
    
   float3 n                = fvNormal;
   n*=n;
   
   float4 fvBaseNormal     = tex2D( normalX, Input.TexcoordX )*n.x+
                             tex2D( normalY, Input.TexcoordY )*n.y+
                             tex2D( normalZ, Input.TexcoordZ )*n.z;
                             
   float3 normal           = normalize(mul(2.0*fvBaseNormal.xyz-1.0,Input.tangentSpace));    
    
   float  fNDotL           = max(0.0,dot( normal, fvLightDirection )); 
   float3 fvReflection     = reflect(fvLightDirection,normal);
   float  fRDotV           = max(0.0, dot( fvReflection, fvViewDirection ) );
   
   float4 fvBaseColor      = tex2D( baseX, Input.TexcoordX )*n.x+
                             tex2D( baseY, Input.TexcoordY )*n.y+
                             tex2D( baseZ, Input.TexcoordZ )*n.z;
                             
   float4 fvTotalAmbient   = fvAmbient * fvBaseColor; 
   float4 fvTotalDiffuse   = fvDiffuse * fNDotL * fvBaseColor; 
   float4 fvTotalSpecular  = fvSpecular * pow( fRDotV, fSpecularPower )*fvBaseColor;
   float4 fresnel          = max(0.0,dot(fvViewDirection,normal))*fvSpecular;
   
   return( fvTotalAmbient + fvTotalDiffuse + fvTotalSpecular+fresnel );
      
}
